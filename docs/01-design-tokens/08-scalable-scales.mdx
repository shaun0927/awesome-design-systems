---
title: "확장 가능한 스케일 시스템"
sidebar_label: "스케일 시스템"
sidebar_position: 8
audience: developer
tags: [tokens, scales, typography, spacing, react]
---

> Original issue: shaun0927/stocktitan-crawler#538

import DevQuickStart from '@site/src/components/DevQuickStart';

<DevQuickStart
  what="Proportional (geometric) scales produce visually consistent size hierarchies that linear pixel grids cannot achieve"
  learn="How to implement modular type and spacing scales with parameterized formulas, and how size vs density dimensions work independently"
  able="Build a complete scale system with TypeScript types and a React component that uses generated tokens"
/>

## 핵심 철학

### 문제 인식: "픽셀 그리드는 쓰레기다"

**기존 8px 그리드 시스템의 한계**:
- 선형 진행(Linear Progression): `8, 16, 24, 32, 40, 48...`
- 절대 차이는 일정(8px)하지만 **상대 차이는 불균형**
  - 8px → 16px = 100% 증가
  - 96px → 104px = 8% 증가
- 결과: 큰 값일수록 차이가 불명확해져 **사용성 저하**
- 컴포넌트 높이 vs 내부 패딩이 그리드에 **동시에 맞지 않음**
- "일관성 없이 적용되는 규칙은 시스템이 아니다"

### 해결 방향: 비례 스케일(Proportional Scale)

```
픽셀 그리드 (선형) → Modular Scale (기하급수적)
절대 차이 고정 → 상대 비율 고정
주관적 예외 발생 → 수학적 일관성 보장
```

---

## 🎯 시스템 설계 원칙

### 1. **캡슐화(Encapsulation)** - 문제를 작은 단위로 분리

복잡한 시스템 문제를 3개의 독립적 관계로 분해:

| 관계 | 입력 | 출력 | 목적 |
|------|------|------|------|
| **반응형(Responsive)** | 뷰포트 너비 | 텍스트/간격 크기 | 화면 크기별 최적화 |
| **확장성(Extensibility)** | 컴포넌트 유형 | 크기/밀도 옵션 | 다양한 UI 패턴 지원 |
| **접근성(Accessibility)** | 사용자 선호 텍스트 크기 | 모든 텍스트 크기 | 개인화 |

**시스템 다이어그램 작성의 중요성**:
- 각 관계를 시각화 → 의존성 파악
- 예: 컴포넌트 높이 = `간격 + line-height + 텍스트 크기`
- **컴포넌트 높이는 직접 제어 대상이 아닌 시스템 출력값**

### 2. **파라미터화(Parameterization)** - 최소 변수로 전체 제어

**타입 스케일 생성 공식**:
```javascript
textSize = baseSize × ratio^n

// 예시: baseSize=16px, ratio=1.2, n=4
textSize = 16 × 1.2^4 = 33.18px → (반올림) 34px
```

**파라미터 분류**:
- **설계 파라미터(Design Parameters)**: 시스템 제작자가 제어
  - `baseSize` (기본 크기)
  - `ratio` (비율)
  - `viewport breakpoints` (중단점)
- **가변 파라미터(Variable Parameters)**: 사용자가 제어
  - 뷰포트 너비
  - 선호 텍스트 크기

### 3. **추상화(Abstraction)** - 공통 패턴을 템플릿화

**컴포넌트 원형(Archetype)** 개념:
- 대부분의 기본 컴포넌트는 동일한 구조를 공유
  - 텍스트 + 아이콘/컨트롤
  - 텍스트-아이콘 간 고정된 간격
  - 경계가 있는 경우 일관된 패딩
- 이 공통 패턴을 **하나의 템플릿**으로 정의
- 모든 컴포넌트가 이 템플릿에서 파생

---

## 🔢 수학적 기반: Modular Scale

### 타입 스케일 (Type Scale)

**기본 공식**:
```javascript
function textSize(base, ratio, n) {
  const size = base * Math.pow(ratio, n);
  // 디자이너를 위한 반올림: 짝수로 정규화
  return Math.round(size / 2) * 2;
}

// 예시
textSize(16, 1.2, 0)  → 16px  (기본)
textSize(16, 1.2, 1)  → 20px  (1단계 크게)
textSize(16, 1.2, -1) → 14px  (1단계 작게)
textSize(16, 1.2, 4)  → 34px  (4단계 크게)
```

**반응형 타입 스케일**:
```javascript
function getResponsiveTextSize(n) {
  let base, ratio;

  if (viewportWidth < 768) {
    base = 14; ratio = 1.15;  // 모바일: 작은 기본, 완만한 비율
  } else if (viewportWidth < 1440) {
    base = 16; ratio = 1.2;   // 태블릿/데스크톱
  } else {
    base = 20; ratio = 1.3;   // 와이드스크린: 큰 기본, 급격한 비율
  }

  return textSize(base, ratio, n);
}
```

**접근성: REM 변환**:
```javascript
// 픽셀 → REM (사용자 브라우저 설정 반영)
function toRem(px) {
  return px / 16;  // 기본 브라우저 폰트는 16px
}

// REM은 사용자가 브라우저 설정에서 폰트 크기 변경 시 자동 스케일
```

### 간격 스케일 (Spacing Scale)

**타입 스케일과 동일한 공식 재사용**:
```javascript
function spacingSize(base, ratio, n) {
  return Math.round((base * Math.pow(ratio, n)) / 2) * 2;
}

// 단, 간격은 픽셀 유지 (REM 변환 안 함)
// 이유: 텍스트 확대가 전체 레이아웃까지 확대하면 안 됨
```

**왜 타입 스케일 공식을 재사용?**
- 간격은 **텍스트 크기에 비례**해야 관계가 유지됨
- 작은 텍스트 옆 간격 vs 큰 텍스트 옆 간격
- 동일한 ratio 사용 → 시각적 일관성 보장

---

## 🎨 적응형 스케일: 크기(Size) vs 밀도(Density)

### 개념 정의

| 차원 | 정의 | 변경 대상 | 사용 목적 |
|------|------|----------|----------|
| **크기(Size)** | 컴포넌트 전체 크기 | 텍스트 크기 + 간격 | **콘텐츠 계층(Content Hierarchy)** 생성 |
| **밀도(Density)** | 내부 간격만 | 간격만 (텍스트 고정) | **공간 효율성(Space Efficiency)** 조절 |

**예시**:
- `<Button size="large">` → 텍스트 18px, 패딩 12/20px (큰 버튼)
- `<Button size="medium" density="compact">` → 텍스트 16px, 패딩 4/8px (좁은 버튼)
- `<Table density="comfortable">` → 셀 텍스트 16px, 패딩 10/16px (넓은 테이블)

### 구현: 상대 인덱스(Relative Index)

**컴포넌트 원형에서 패딩을 인덱스로 정의**:
```javascript
const componentArchetype = {
  textIndex: 0,           // 기본 텍스트 크기
  paddingVertical: -4,    // 기본 크기보다 4단계 작음 (6px)
  paddingHorizontal: -1,  // 기본 크기보다 1단계 작음 (12px)
  gap: -3                 // 텍스트-아이콘 간격: 3단계 작음 (8px)
};
```

**크기 옵션 생성**:
```javascript
const sizeOffsets = {
  small: -1,    // 모든 인덱스를 -1
  medium: 0,    // 기본
  large: 1      // 모든 인덱스를 +1
};

function getComponentSize(size) {
  const offset = sizeOffsets[size];
  return {
    textSize: textSize(base, ratio, 0 + offset),
    paddingV: spacingSize(base, ratio, -4 + offset),
    paddingH: spacingSize(base, ratio, -1 + offset)
  };
}

// 결과:
// small:  textSize(16, 1.2, -1) = 14px, padding = 4/10px
// medium: textSize(16, 1.2, 0)  = 16px, padding = 6/12px
// large:  textSize(16, 1.2, 1)  = 20px, padding = 8/14px
```

**밀도 옵션 생성**:
```javascript
const densityOffsets = {
  compact: -1,
  regular: 0,
  comfortable: 1
};

const densityFactor = 2;  // 밀도 차이를 더 극명하게 (선택사항)

function getComponentDensity(size, density) {
  const sizeOffset = sizeOffsets[size];
  const densityOffset = densityOffsets[density] * densityFactor;

  return {
    textSize: textSize(base, ratio, 0 + sizeOffset),  // 텍스트는 크기만 반영
    paddingV: spacingSize(base, ratio, -4 + sizeOffset + densityOffset),
    paddingH: spacingSize(base, ratio, -1 + sizeOffset + densityOffset)
  };
}
```

---

## 💻 코드 구현 예시

### 전체 시스템 통합

```javascript
// 설계 파라미터
const config = {
  viewports: [
    { max: 768, base: 14, ratio: 1.15 },
    { max: 1440, base: 16, ratio: 1.2 },
    { max: Infinity, base: 20, ratio: 1.3 }
  ],
  densityFactor: 2
};

// 현재 뷰포트 설정 가져오기
function getCurrentConfig() {
  const vw = window.innerWidth;
  return config.viewports.find(v => vw <= v.max);
}

// 텍스트 크기 계산 (REM으로 출력)
function getTextSize(index) {
  const { base, ratio } = getCurrentConfig();
  const px = Math.round((base * Math.pow(ratio, index)) / 2) * 2;
  return `${px / 16}rem`;  // 접근성을 위한 REM 변환
}

// 간격 크기 계산 (픽셀로 출력)
function getSpacingSize(index) {
  const { base, ratio } = getCurrentConfig();
  return Math.round((base * Math.pow(ratio, index)) / 2) * 2;
}

// 컴포넌트 스타일 생성
function getComponentStyle(size, density) {
  const sizeOffset = { small: -1, medium: 0, large: 1 }[size];
  const densityOffset = { compact: -1, regular: 0, comfortable: 1 }[density];
  const densityShift = densityOffset * config.densityFactor;

  return {
    fontSize: getTextSize(0 + sizeOffset),
    paddingTop: `${getSpacingSize(-4 + sizeOffset + densityShift)}px`,
    paddingBottom: `${getSpacingSize(-4 + sizeOffset + densityShift)}px`,
    paddingLeft: `${getSpacingSize(-1 + sizeOffset + densityShift)}px`,
    paddingRight: `${getSpacingSize(-1 + sizeOffset + densityShift)}px`,
    gap: `${getSpacingSize(-3 + sizeOffset + densityShift)}px`
  };
}
```

### CSS 변수(Design Tokens) 생성

```javascript
function generateCSSVariables() {
  const { base, ratio } = getCurrentConfig();
  const root = document.documentElement;

  // 타입 스케일 토큰
  for (let i = -4; i <= 8; i++) {
    const size = Math.round((base * Math.pow(ratio, i)) / 2) * 2;
    root.style.setProperty(`--text-${i}`, `${size / 16}rem`);
  }

  // 간격 스케일 토큰
  for (let i = -4; i <= 8; i++) {
    const size = Math.round((base * Math.pow(ratio, i)) / 2) * 2;
    root.style.setProperty(`--space-${i}`, `${size}px`);
  }

  // 컴포넌트 시맨틱 토큰
  root.style.setProperty('--button-text-medium', 'var(--text-0)');
  root.style.setProperty('--button-padding-v-medium', 'var(--space--4)');
  root.style.setProperty('--button-padding-h-medium', 'var(--space--1)');
}

// 초기화 및 반응형 업데이트
generateCSSVariables();
window.addEventListener('resize', generateCSSVariables);
```

---

## ✅ 실전 체크리스트

### 시스템 구축 단계

- [ ] **1단계: 문제 분해**
  - [ ] 시스템 다이어그램 작성 (입력 → 출력 관계)
  - [ ] 3가지 관계 식별: 반응형, 확장성, 접근성
  - [ ] 각 관계를 독립적인 문제로 캡슐화

- [ ] **2단계: 타입 스케일 정의**
  - [ ] 기본 크기(baseSize) 선택: 모바일 14px, 데스크톱 16px, 와이드 20px
  - [ ] 비율(ratio) 선택: 1.15 ~ 1.3 (완만 ~ 급격)
  - [ ] 뷰포트별 조건부 설정 구현
  - [ ] REM 변환 (접근성)
  - [ ] 반올림 규칙 (짝수 선호)

- [ ] **3단계: 간격 스케일 정의**
  - [ ] 타입 스케일 공식 재사용
  - [ ] 픽셀 단위 유지 (REM 변환 안 함)
  - [ ] 뷰포트 반응형 지원

- [ ] **4단계: 컴포넌트 원형 설계**
  - [ ] 기본 컴포넌트들의 공통 패턴 추출
  - [ ] 패딩/간격을 상대 인덱스로 정의
  - [ ] 크기 옵션 배열 정의 (small/medium/large)
  - [ ] 밀도 옵션 배열 정의 (compact/regular/comfortable)
  - [ ] 밀도 계수(densityFactor) 결정

- [ ] **5단계: 구현 및 테스트**
  - [ ] CSS 변수/디자인 토큰 생성
  - [ ] 반응형 업데이트 로직 구현
  - [ ] 다양한 뷰포트/텍스트 크기에서 테스트
  - [ ] 접근성 검증 (브라우저 폰트 크기 변경 테스트)

## TypeScript 타입 정의

```typescript title="types/scale-system.ts"
type ScaleSize = 'small' | 'medium' | 'large';
type ScaleDensity = 'compact' | 'regular' | 'comfortable';

interface ScaleConfig {
  base: number;
  ratio: number;
  stepsDown: number;
  stepsUp: number;
}

interface ViewportConfig extends ScaleConfig {
  maxWidth: number;
}

interface ComponentStyle {
  fontSize: string;
  paddingTop: string;
  paddingBottom: string;
  paddingLeft: string;
  paddingRight: string;
  gap: string;
}

function getComponentStyle(
  size: ScaleSize,
  density: ScaleDensity,
  config: ScaleConfig
): ComponentStyle {
  const sizeOffset = { small: -1, medium: 0, large: 1 }[size];
  const densityOffset = { compact: -1, regular: 0, comfortable: 1 }[density];
  const densityShift = densityOffset * 2;

  const textPx = Math.round(
    (config.base * Math.pow(config.ratio, sizeOffset)) / 2
  ) * 2;
  const paddingV = Math.round(
    (config.base * Math.pow(config.ratio, -4 + sizeOffset + densityShift)) / 2
  ) * 2;
  const paddingH = Math.round(
    (config.base * Math.pow(config.ratio, -1 + sizeOffset + densityShift)) / 2
  ) * 2;
  const gapPx = Math.round(
    (config.base * Math.pow(config.ratio, -3 + sizeOffset + densityShift)) / 2
  ) * 2;

  return {
    fontSize: `${textPx / 16}rem`,
    paddingTop: `${paddingV}px`,
    paddingBottom: `${paddingV}px`,
    paddingLeft: `${paddingH}px`,
    paddingRight: `${paddingH}px`,
    gap: `${gapPx}px`,
  };
}
```

## React 컴포넌트 예시

```tsx title="ScaledButton.tsx"
import React from 'react';

type Size = 'small' | 'medium' | 'large';
type Density = 'compact' | 'regular' | 'comfortable';

interface ScaledButtonProps {
  size?: Size;
  density?: Density;
  children: React.ReactNode;
  onClick?: () => void;
}

const BASE = 16;
const RATIO = 1.2;

function scale(index: number): number {
  return Math.round((BASE * Math.pow(RATIO, index)) / 2) * 2;
}

export function ScaledButton({
  size = 'medium',
  density = 'regular',
  children,
  onClick,
}: ScaledButtonProps) {
  const sizeOffset = { small: -1, medium: 0, large: 1 }[size];
  const densityOffset = { compact: -2, regular: 0, comfortable: 2 }[density];

  const style: React.CSSProperties = {
    fontSize: `${scale(sizeOffset) / 16}rem`,
    paddingBlock: `${scale(-4 + sizeOffset + densityOffset)}px`,
    paddingInline: `${scale(-1 + sizeOffset + densityOffset)}px`,
    gap: `${scale(-3 + sizeOffset + densityOffset)}px`,
    display: 'inline-flex',
    alignItems: 'center',
    borderRadius: 'var(--radius-md)',
    border: 'none',
    background: 'var(--color-brand-primary)',
    color: 'var(--color-text-on-primary)',
    cursor: 'pointer',
  };

  return (
    <button style={style} onClick={onClick}>
      {children}
    </button>
  );
}

// Usage:
// <ScaledButton size="large" density="compact">Submit</ScaledButton>
// <ScaledButton size="small" density="comfortable">Cancel</ScaledButton>
```

## 추천 도구

| 도구 | 용도 | URL |
|------|------|-----|
| **Proportio** | Modular Scale 계산기 | [proportio.app](https://proportio.app) |
| **Utopia** | CSS clamp() 기반 Fluid 타이포그래피 | [utopia.fyi](https://utopia.fyi) |
| **Token Studio** | Figma 플러그인 (시스템 다이어그램 → 토큰) | [tokens.studio](https://tokens.studio) |

## 주요 인사이트

1. **"픽셀 그리드는 시스템이 아니다"** - 주관적 예외가 필요한 규칙은 확장 불가
2. **컴포넌트 높이는 출력값이지 입력값이 아니다** - 간격+텍스트 크기가 높이를 결정
3. **크기(Size) =/= 밀도(Density)** - 계층 구조 vs 공간 효율성은 별개 차원
4. **파라미터 2개로 수백 개의 값을 제어** - baseSize + ratio = 전체 스케일 시스템

---
*출처: Nate Baldwin (Adobe Spectrum)*

---

## 📎 Related Articles

import CrossRef from '@site/src/components/CrossRef';

<CrossRef
  related={[
    { path: "/docs/visual-foundations/typography", label: "타이포그래피 시스템" },
    { path: "/docs/visual-foundations/spacing", label: "스페이싱 시스템" },
    { path: "/docs/component-design/subcomponents", label: "Subcomponents - 조합 가능한 부품" },
  ]}
/>
