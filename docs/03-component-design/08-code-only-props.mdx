---
title: "Code Only Props - ë¹„ì‹œê°ì  ì†ì„± ê´€ë¦¬"
sidebar_label: "Code Only Props"
sidebar_position: 8
audience: both
tags: [props, figma, accessibility, typescript]
---

import DevQuickStart from '@site/src/components/DevQuickStart';

<DevQuickStart
  what="Code Only Props are non-visual properties (accessibility, semantic HTML tags, behavior constraints) that exist in Figma but only render in code"
  learn="How to create hidden Figma layers for code-only props, visibility strategies, and type inference rules from Figma to TypeScript"
  able="Map Figma code-only prop definitions to TypeScript interfaces with proper type inference"
/>

## í•µì‹¬ ê°œë…

**ë¬¸ì œ**: FigmaëŠ” ì‹œê°ì  ê²°ê³¼ë¬¼ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ê³„ë˜ì–´ ì ‘ê·¼ì„±, ë™ì‘, ë¹„ì‹œê°ì  ë¡œì§ í‘œí˜„ ìˆ˜ë‹¨ì´ ì œí•œì 

**ì†”ë£¨ì…˜**: ì‹¤ì œë¡œëŠ” ë³´ì´ì§€ ì•Šì§€ë§Œ Figma ì»´í¬ë„ŒíŠ¸ êµ¬ì¡° ë‚´ì— ì¡´ì¬í•˜ëŠ” "Code Only Props" ë ˆì´ì–´

## ğŸ¯ ì‹¤ë¬´ ë…¸í•˜ìš°

### êµ¬í˜„ í”„ë¡œì„¸ìŠ¤

**Step 1: Code only props ë ˆì´ì–´ ìƒì„±**
```
1. ì»´í¬ë„ŒíŠ¸ ë£¨íŠ¸ì˜ ìì‹ìœ¼ë¡œ í”„ë ˆì„ ì¶”ê°€
2. ì´ë¦„: "Code only props"
3. ìœ„ì¹˜: X=0, Y=0
4. í¬ê¸°: W=0.01, H=0.01
5. Clip content í™œì„±í™”
```

**Step 2: ê° propë³„ ë ˆì´ì–´ ì¶”ê°€**
- TEXT ë ˆì´ì–´ â†’ ì»´í¬ë„ŒíŠ¸ propì— ë°”ì¸ë”©
- VARIANT ë ˆì´ì–´ â†’ ë³„ë„ ì»´í¬ë„ŒíŠ¸ ìƒì„± (ì˜ˆ: "as" ì»´í¬ë„ŒíŠ¸)
- í•„ìš”ì‹œ ë ˆì´ì–´ ìˆ¨ê¹€ (í”„ë¡œë•íŠ¸ ë””ìì´ë„ˆì—ê²Œ ë¶ˆí•„ìš”í•œ ê²½ìš°)

**Step 3: ìë™í™” í†µí•©**
- Anova í”ŒëŸ¬ê·¸ì¸ ë“±ì´ Code only props ë ˆì´ì–´ íƒìƒ‰
- ìì‹ ë ˆì´ì–´ì˜ prop ê°’ ì½ê¸°
- spec dataë¡œ ë³€í™˜

### ë…¸ì¶œ ì „ëµ (Visibility Strategy)

| ìƒí™© | ë ˆì´ì–´ í‘œì‹œ | í”„ë¡œë•íŠ¸ ë””ìì´ë„ˆê°€ ë´„ |
|------|------------|---------------------|
| ì ‘ê·¼ì„± í•„ìˆ˜ í•­ëª© | âœ… | âœ… (ì…ë ¥ ê°€ëŠ¥) |
| í”Œë«í¼ë³„ ê¸°ìˆ  ì†ì„± | âŒ | âŒ (ìë™í™” ì „ìš©) |
| ë™ì‘ ì œì•½ ì¡°ê±´ | âŒ ë˜ëŠ” âœ… | ì„ íƒì  |

### íƒ€ì… ì¶”ë¡  ê·œì¹™

```yaml
"Label"     â†’ type: string
"0"         â†’ type: number
"h1|h2|h3"  â†’ type: string, enum: [h1, h2, h3]
```

## ğŸ“Š ì˜ˆì‹œ

### Heading ì»´í¬ë„ŒíŠ¸
```yaml
props:
  as:
    type: string
    enum: [h1, h2, h3, h4, h5, h6]
    default: h1
  level:
    type: number
    enum: [1, 2, 3, 4, 5, 6]
    default: 1
```

### Checkbox Group (Slot ì œì•½)
```yaml
props:
  items anyOf:
    type: text
    value: "checkbox"
    codeOnly: true
  items minItems:
    type: text
    value: "1"
    codeOnly: true
```

## ğŸ”Œ Anova í”ŒëŸ¬ê·¸ì¸ ëŒ€ì•ˆ

AnovaëŠ” ìƒìš© í”ŒëŸ¬ê·¸ì¸ì´ë¯€ë¡œ, ì˜¤í”ˆì†ŒìŠ¤ ëŒ€ì•ˆ ë° ìˆ˜ë™ ì ‘ê·¼ë²•ì„ ì†Œê°œí•©ë‹ˆë‹¤.

### ë°©ë²• 1: Figma REST API í™œìš©

Figmaì˜ ê³µì‹ REST APIë¥¼ ì‚¬ìš©í•´ ì½”ë“œ ì „ìš© propsë¥¼ í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ ì¶”ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript
// figma-code-props-extractor.ts
interface FigmaNode {
  id: string;
  name: string;
  type: string;
  children?: FigmaNode[];
  characters?: string; // TEXT ë…¸ë“œì˜ í…ìŠ¤íŠ¸ ë‚´ìš©
}

interface CodeOnlyProp {
  name: string;
  value: string;
  type: 'string' | 'number' | 'enum';
  enumValues?: string[];
}

async function extractCodeOnlyProps(
  fileKey: string,
  componentNodeId: string,
  figmaToken: string
): Promise<CodeOnlyProp[]> {
  // Step 1: Figma REST APIë¡œ ì»´í¬ë„ŒíŠ¸ ë…¸ë“œ ê°€ì ¸ì˜¤ê¸°
  const response = await fetch(
    `https://api.figma.com/v1/files/${fileKey}/nodes?ids=${componentNodeId}`,
    {
      headers: { 'X-Figma-Token': figmaToken }
    }
  );

  const data = await response.json();
  const componentNode = data.nodes[componentNodeId].document;

  // Step 2: "Code only props" í”„ë ˆì„ ì°¾ê¸°
  const codePropsFrame = findChildByName(componentNode, 'Code only props');
  if (!codePropsFrame) {
    throw new Error('Code only props frame not found');
  }

  // Step 3: ê° TEXT ë ˆì´ì–´ë¥¼ propìœ¼ë¡œ íŒŒì‹±
  const props: CodeOnlyProp[] = [];

  for (const child of codePropsFrame.children || []) {
    if (child.type !== 'TEXT') continue;

    const propName = child.name;
    const propValue = child.characters || '';

    // íƒ€ì… ì¶”ë¡ 
    const prop = inferPropType(propName, propValue);
    props.push(prop);
  }

  return props;
}

function findChildByName(node: FigmaNode, name: string): FigmaNode | null {
  if (node.name === name) return node;

  for (const child of node.children || []) {
    const found = findChildByName(child, name);
    if (found) return found;
  }

  return null;
}

function inferPropType(name: string, value: string): CodeOnlyProp {
  // "h1|h2|h3" â†’ enum
  if (value.includes('|')) {
    const enumValues = value.split('|').map(v => v.trim());
    return {
      name,
      value,
      type: 'enum',
      enumValues
    };
  }

  // "0", "1", "42" â†’ number
  if (/^\d+$/.test(value)) {
    return {
      name,
      value,
      type: 'number'
    };
  }

  // Default â†’ string
  return {
    name,
    value,
    type: 'string'
  };
}

// Usage
const props = await extractCodeOnlyProps(
  'ABC123', // Figma file key
  '1:234',  // Component node ID
  process.env.FIGMA_TOKEN!
);

console.log(props);
// [
//   { name: 'as', value: 'h1|h2|h3|h4|h5|h6', type: 'enum', enumValues: ['h1', 'h2', ...] },
//   { name: 'level', value: '1|2|3|4|5|6', type: 'enum', enumValues: ['1', '2', ...] }
// ]
```

### ë°©ë²• 2: Figma Plugin APIë¡œ ì»¤ìŠ¤í…€ í”ŒëŸ¬ê·¸ì¸ ì œì‘

ì§ì ‘ Figma í”ŒëŸ¬ê·¸ì¸ì„ ë§Œë“¤ì–´ code-only propsë¥¼ ì¶”ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript
// figma-plugin-code.ts (Figma Plugin Sandboxì—ì„œ ì‹¤í–‰)
figma.showUI(__html__, { width: 400, height: 300 });

// í˜„ì¬ ì„ íƒëœ ì»´í¬ë„ŒíŠ¸ì—ì„œ code-only props ì¶”ì¶œ
const selection = figma.currentPage.selection[0];

if (selection && selection.type === 'COMPONENT') {
  const codeProps = extractCodePropsFromComponent(selection);

  // UIì— ì „ë‹¬ (JSONìœ¼ë¡œ ë³€í™˜)
  figma.ui.postMessage({
    type: 'code-props-extracted',
    data: codeProps
  });
}

function extractCodePropsFromComponent(component: ComponentNode) {
  // "Code only props" í”„ë ˆì„ ì°¾ê¸°
  const codePropsFrame = component.children.find(
    child => child.name === 'Code only props' && child.type === 'FRAME'
  ) as FrameNode | undefined;

  if (!codePropsFrame) {
    return [];
  }

  const props: Array<{ name: string; value: string; visible: boolean }> = [];

  // TEXT ë ˆì´ì–´ë¥¼ ìˆœíšŒí•˜ë©° prop ì¶”ì¶œ
  for (const child of codePropsFrame.children) {
    if (child.type === 'TEXT') {
      props.push({
        name: child.name,
        value: (child as TextNode).characters,
        visible: child.visible
      });
    }
  }

  return props;
}

// UI ì½”ë“œ (HTML + JavaScript)
const __html__ = `
<script>
  window.onmessage = (event) => {
    const { type, data } = event.data.pluginMessage;
    if (type === 'code-props-extracted') {
      document.getElementById('output').textContent = JSON.stringify(data, null, 2);
    }
  };
</script>
<pre id="output">Select a component to extract code-only props...</pre>
`;
```

### ë°©ë²• 3: ìˆ˜ë™ ë¬¸ì„œí™” (Markdown Table)

ìë™í™”ê°€ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°, ë””ìì´ë„ˆê°€ Markdown í…Œì´ë¸”ë¡œ code-only propsë¥¼ ë¬¸ì„œí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```markdown
## Button Component - Code Only Props

| Prop Name | Type | Values | Default | Description |
|-----------|------|--------|---------|-------------|
| `as` | enum | `button`, `a`, `div` | `button` | Semantic HTML tag |
| `disabled` | boolean | `true`, `false` | `false` | Disable interactions |
| `loading` | boolean | `true`, `false` | `false` | Show loading spinner |
| `type` | enum | `button`, `submit`, `reset` | `button` | Button type attribute |
| `ariaLabel` | string | Any string | - | Accessibility label |
```

ê°œë°œìëŠ” ì´ í…Œì´ë¸”ì„ TypeScript interfaceë¡œ ë³€í™˜:

```typescript
interface ButtonCodeOnlyProps {
  as?: 'button' | 'a' | 'div';
  disabled?: boolean;
  loading?: boolean;
  type?: 'button' | 'submit' | 'reset';
  ariaLabel?: string;
}
```

---

## ğŸ”§ ê°œì„ ëœ TypeScript íƒ€ì… ì¶”ë¡  ìœ í‹¸ë¦¬í‹°

ê¸°ì¡´ `InferFigmaPropType`ë¥¼ ë” í˜„ì‹¤ì ìœ¼ë¡œ ê°œì„ í•œ ë²„ì „ì…ë‹ˆë‹¤.

```typescript
// í–¥ìƒëœ íƒ€ì… ì¶”ë¡  ì‹œìŠ¤í…œ
type InferFigmaPropType<T extends string> =
  // "true|false" â†’ boolean
  T extends 'true|false' | 'false|true' ? boolean :
  // "1|2|3" (ìˆ«ìë§Œ) â†’ number enum
  T extends `${number}` ? number :
  T extends `${number}|${infer Rest}` ?
    Rest extends `${number}` | `${number}|${string}`
      ? number  // ëª¨ë“  ê°’ì´ ìˆ«ìë©´ number
      : string  // í•˜ë‚˜ë¼ë„ ë¬¸ìë©´ string enum
    : never :
  // "value1|value2|value3" â†’ string enum
  T extends `${string}|${string}` ? string :
  // "0", "42" (ë‹¨ì¼ ìˆ«ì) â†’ number
  T extends `${number}` ? number :
  // ê¸°ë³¸ê°’ â†’ string
  string;

// í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
type Test1 = InferFigmaPropType<'h1|h2|h3'>;        // string
type Test2 = InferFigmaPropType<'1|2|3|4|5|6'>;     // number
type Test3 = InferFigmaPropType<'true|false'>;      // boolean
type Test4 = InferFigmaPropType<'Label text'>;      // string
type Test5 = InferFigmaPropType<'42'>;              // number

// Enum ê°’ ì¶”ì¶œ ìœ í‹¸ë¦¬í‹°
type ExtractEnumValues<T extends string> =
  T extends `${infer First}|${infer Rest}`
    ? First | ExtractEnumValues<Rest>
    : T;

type HeadingLevels = ExtractEnumValues<'h1|h2|h3|h4|h5|h6'>;
// Result: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'

// ì‹¤ì „ ì ìš©: Figma spec â†’ TypeScript interface
interface FigmaCodePropSpec {
  name: string;
  value: string;
}

type SpecToProps<T extends readonly FigmaCodePropSpec[]> = {
  [K in T[number] as K['name']]: InferFigmaPropType<K['value']> extends boolean
    ? boolean
    : InferFigmaPropType<K['value']> extends number
      ? ExtractEnumValues<K['value']> extends `${number}`
        ? number  // ìˆœìˆ˜ number enum
        : never
      : ExtractEnumValues<K['value']>;  // string literal union
};

// ì‚¬ìš© ì˜ˆì‹œ
const headingSpec = [
  { name: 'as', value: 'h1|h2|h3|h4|h5|h6' },
  { name: 'level', value: '1|2|3|4|5|6' },
  { name: 'truncate', value: 'true|false' }
] as const;

type HeadingProps = SpecToProps<typeof headingSpec>;
// Result:
// {
//   as: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
//   level: '1' | '2' | '3' | '4' | '5' | '6';
//   truncate: boolean;
// }
```

---

## ğŸ’¼ ì‹¤ì „ ì˜ˆì‹œ: Button ì»´í¬ë„ŒíŠ¸ (Code-Only Props í¬í•¨)

### Figma "Code Only Props" ë ˆì´ì–´ êµ¬ì¡°

```
Button Component
â”œâ”€â”€ Visual layers (background, text, icon)
â””â”€â”€ Code only props (Frame, W=0.01, H=0.01, Clip=true)
    â”œâ”€â”€ as (TEXT: "button|a|div")
    â”œâ”€â”€ type (TEXT: "button|submit|reset")
    â”œâ”€â”€ disabled (TEXT: "true|false")
    â”œâ”€â”€ loading (TEXT: "true|false")
    â”œâ”€â”€ ariaLabel (TEXT: "Descriptive label")
    â””â”€â”€ onClick (TEXT: "() => void")
```

### ì¶”ì¶œëœ Spec

```typescript
const buttonCodeOnlySpec = [
  { name: 'as', value: 'button|a|div' },
  { name: 'type', value: 'button|submit|reset' },
  { name: 'disabled', value: 'true|false' },
  { name: 'loading', value: 'true|false' },
  { name: 'ariaLabel', value: 'Accessible label' },
  { name: 'onClick', value: '() => void' }
] as const;
```

### ìƒì„±ëœ TypeScript Interface

```typescript
interface ButtonVisualProps {
  /** Visual: shown in Figma */
  variant: 'primary' | 'secondary' | 'tertiary';
  size: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
  icon?: React.ReactNode;
}

interface ButtonCodeOnlyProps {
  /** Code-only: semantic HTML tag */
  as?: 'button' | 'a' | 'div';
  /** Code-only: button type attribute */
  type?: 'button' | 'submit' | 'reset';
  /** Code-only: disable interactions */
  disabled?: boolean;
  /** Code-only: show loading spinner */
  loading?: boolean;
  /** Code-only: accessibility label (overrides children) */
  ariaLabel?: string;
  /** Code-only: click handler */
  onClick?: () => void;
  /** Code-only: href for 'a' tag variant */
  href?: string;
}

// ìµœì¢… ë³‘í•©ëœ Props
type ButtonProps = ButtonVisualProps & ButtonCodeOnlyProps;
```

### React Component êµ¬í˜„

```typescript
import React from 'react';
import { Spinner } from './Spinner';

export function Button({
  // Visual props
  variant = 'primary',
  size = 'md',
  children,
  icon,

  // Code-only props
  as: Component = 'button',
  type = 'button',
  disabled = false,
  loading = false,
  ariaLabel,
  onClick,
  href
}: ButtonProps) {
  // Link ë³€í˜• ì²˜ë¦¬
  const isLink = Component === 'a' || href;
  const actualComponent = isLink ? 'a' : Component;

  // ë¡œë”© ì¤‘ì´ë©´ ë¹„í™œì„±í™”
  const isDisabled = disabled || loading;

  const handleClick = (e: React.MouseEvent) => {
    if (isDisabled) {
      e.preventDefault();
      return;
    }
    onClick?.();
  };

  return React.createElement(
    actualComponent,
    {
      className: `btn btn--${variant} btn--${size}`,
      type: actualComponent === 'button' ? type : undefined,
      disabled: actualComponent === 'button' ? isDisabled : undefined,
      'aria-label': ariaLabel,
      'aria-disabled': isDisabled,
      'aria-busy': loading,
      href: isLink ? href : undefined,
      onClick: handleClick
    },
    <>
      {loading && <Spinner size={size} />}
      {icon && !loading && <span className="btn__icon">{icon}</span>}
      <span className="btn__text">{children}</span>
    </>
  );
}
```

### Storybook Examples

```typescript
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';

const meta: Meta<typeof Button> = {
  title: 'Components/Button',
  component: Button,
  argTypes: {
    // Visual props (from Figma variants)
    variant: {
      control: 'select',
      options: ['primary', 'secondary', 'tertiary']
    },
    size: {
      control: 'select',
      options: ['sm', 'md', 'lg']
    },

    // Code-only props (not visible in Figma)
    as: {
      control: 'select',
      options: ['button', 'a', 'div'],
      description: 'Code-only: Semantic HTML tag'
    },
    type: {
      control: 'select',
      options: ['button', 'submit', 'reset'],
      description: 'Code-only: Button type attribute'
    },
    disabled: {
      control: 'boolean',
      description: 'Code-only: Disable interactions'
    },
    loading: {
      control: 'boolean',
      description: 'Code-only: Show loading spinner'
    }
  }
};

export default meta;
type Story = StoryObj<typeof Button>;

// Visual propsë§Œ ì‚¬ìš© (Figmaì—ì„œ ë³´ì´ëŠ” ê²ƒ)
export const Primary: Story = {
  args: {
    variant: 'primary',
    size: 'md',
    children: 'Click me'
  }
};

// Code-only props í™œìš© (Figmaì—ì„œ ë³´ì´ì§€ ì•ŠìŒ)
export const LoadingState: Story = {
  args: {
    variant: 'primary',
    loading: true,  // Code-only prop
    children: 'Processing...'
  }
};

export const DisabledState: Story = {
  args: {
    variant: 'primary',
    disabled: true,  // Code-only prop
    children: 'Disabled button'
  }
};

export const AsLink: Story = {
  args: {
    variant: 'primary',
    as: 'a',  // Code-only prop
    href: 'https://example.com',  // Code-only prop
    children: 'Link styled as button'
  }
};

export const SubmitButton: Story = {
  args: {
    variant: 'primary',
    type: 'submit',  // Code-only prop
    children: 'Submit form'
  }
};
```

---

## ğŸ¯ Design-to-Code Pipeline with Code-Only Props

```mermaid
graph LR
    A[Figma Component] --> B[Extract Visual Props<br/>variants, sizes, colors]
    A --> C[Extract Code-Only Props<br/>hidden layer parsing]

    B --> D[Generate Visual Interface]
    C --> E[Generate Code Interface]

    D --> F[Merge Interfaces]
    E --> F

    F --> G[Generate React Component]

    G --> H[Storybook Stories]
    G --> I[TypeScript Types]
    G --> J[Unit Tests]

    style A fill:#f3e8ff,stroke:#7c3aed
    style F fill:#fef3c7,stroke:#d97706
    style G fill:#d1fae5,stroke:#059669
```

---

## Figma to TypeScript Mapping

Use the `InferFigmaPropType` and `SpecToProps` utilities shown above to automatically generate TypeScript interfaces from Figma component properties. This ensures type safety and eliminates manual synchronization errors.

---

## ğŸ“ Related Articles

import CrossRef from '@site/src/components/CrossRef';

<CrossRef
  related={[
    { path: "/docs/component-design/figma-slots", label: "Figma Slots for Repeating Items" },
    { path: "/docs/component-design/states", label: "States Management - ìƒíƒœ ê´€ë¦¬ì˜ ì •ì„" },
    { path: "/docs/component-documentation/spec-guide", label: "ì»´í¬ë„ŒíŠ¸ ëª…ì„¸ì„œ ì‘ì„± ê°€ì´ë“œ" },
  ]}
/>
