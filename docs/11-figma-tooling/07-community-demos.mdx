---
title: "ë””ìì¸ ì‹œìŠ¤í…œ ì»¤ë®¤ë‹ˆí‹° ë°ëª¨ - Tokens, Tooling & Accessibility"
sidebar_label: "Community Demos"
sidebar_position: 7
audience: both
tags: ["tokens", "tooling", "accessibility", "WCAG", "community"]
---

import DevQuickStart from '@site/src/components/DevQuickStart';

<DevQuickStart
  what="Three community demos covering token naming strategies (Tokens Glossary), AI-powered handoff automation (Quantum Plugin), and physical WCAG Card Decks for accessibility audits"
  learn="How to resolve token naming conflicts with a synonym database, automate Figma-to-GitHub issue creation with GPT-4, and run structured WCAG audits with card-based triage"
  able="Build a semantic token glossary, set up AI-driven change detection for design-dev handoff, and conduct a prioritized accessibility audit using the WCAG Card Deck method"
/>

## í•µì‹¬ ì¸ì‚¬ì´íŠ¸

1. **í† í° ëª…ëª…ì€ ì „ëµì  íˆ¬ì** -- ë¹ ë¥¸ MVPë¡œ ê°€ì¹˜ ì…ì¦ í›„ ì‹œê°„ í™•ë³´
2. **AIëŠ” í† í° ëª…ëª…ì˜ ë³´ì¡° ë„êµ¬** -- ì‹¤ì œ ì œì•½ì‚¬í•­ì„ í•™ìŠµì‹œí‚¨ ì»¤ìŠ¤í…€ ì±—ë´‡ì´ ìœ ìš©
3. **í•¸ë“œì˜¤í”„ ìë™í™”ëŠ” ì±…ì„ ëª…í™•í™”** -- "ë””ìì´ë„ˆëŠ” ì´ìŠˆ ì•ˆ ì“´ë‹¤"ëŠ” í˜„ì‹¤ ì¸ì •
4. **ì ‘ê·¼ì„±ì€ ëª¨ë‘ì˜ ë¬¸ì œ** -- ìˆ™ì·¨, í¸ë‘í†µ, ë‹¹ë‡¨ ëª¨ë‘ íë¦¿í•œ ì‹œì•¼ ìœ ë°œ

---

## Demo 1: Tokens Glossary (Marta K)

### ë¬¸ì œ ì •ì˜

ëŒ€ê·œëª¨ ë””ìì¸ ì‹œìŠ¤í…œì—ì„œ í† í° ëª…ëª…ì€ ë‹¨ìˆœíˆ "ì´ë¦„ ì§“ê¸°"ê°€ ì•„ë‹™ë‹ˆë‹¤. **ì—¬ëŸ¬ íŒ€, ì—¬ëŸ¬ ë¸Œëœë“œ, ì—¬ëŸ¬ í”Œë«í¼**ì—ì„œ ì¼ê´€ë˜ê²Œ ì‘ë™í•´ì•¼ í•˜ëŠ” **ì–¸ì–´ ì‹œìŠ¤í…œ**ì…ë‹ˆë‹¤.

**í˜„ì‹¤ì  ì œì•½ì‚¬í•­**:
- ê¸°ì¡´ ì½”ë“œë² ì´ìŠ¤ì— ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ í† í°ëª…
- ë‹¤ë¥¸ íŒ€ì˜ ë„¤ì´ë° ì»¨ë²¤ì…˜
- í”Œë«í¼ ì œì•½ (iOSëŠ” camelCase, AndroidëŠ” snake_case)
- ë¸Œëœë“œë³„ semantic ì°¨ì´ (ì–´ë–¤ ë¸Œëœë“œëŠ” "warning"ì´ ë¹¨ê°•, ë‹¤ë¥¸ ë¸Œëœë“œëŠ” ë…¸ë‘)

### 4ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤

```mermaid
graph LR
    A["ìƒíƒœê³„ ì´í•´<br/>90 Days Canvas"] --> B["MVP ë¦¬ë¸Œëœë”©<br/>15ê°œ ì»´í¬ë„ŒíŠ¸"]
    B --> C["êµ¬ì¡° ë¶„ì„<br/>Border/BG/Icon/Text"]
    C --> D["ì œì•½ì‚¬í•­ ë¬¸ì„œí™”"]
    D --> E["Glossary êµ¬ì¶•"]
    E --> F["AI Chatbot í•™ìŠµ"]

    style B fill:#d1fae5,stroke:#059669
    style E fill:#dbeafe,stroke:#2563eb
```

#### Step 1: 90 Days Canvas (Ecosystem Understanding)

```typescript
// ecosystem-mapping.ts
// ì²« 90ì¼ ë™ì•ˆ ìƒíƒœê³„ ì „ì²´ë¥¼ ë§¤í•‘

interface Ecosystem {
  teams: Team[];
  brands: Brand[];
  platforms: Platform[];
  existingTokens: ExistingTokenSet[];
}

interface Team {
  name: string;
  namingConvention: 'BEM' | 'Atomic' | 'ITCSS' | 'Custom';
  primaryLanguage: 'CSS' | 'SCSS' | 'Tailwind' | 'CSS-in-JS';
  tokenFormat: 'kebab-case' | 'camelCase' | 'snake_case';
}

interface Brand {
  name: string;
  colorSemantics: Record<string, string>; // 'danger' â†’ '#FF0000'
  typographyScale: 'numeric' | 'tshirt' | 'named';
}

interface Platform {
  name: 'iOS' | 'Android' | 'Web' | 'React Native';
  tokenFormat: string;
  constraints: string[];
}

// Example mapping
const ecosystemMap: Ecosystem = {
  teams: [
    {
      name: 'Product Team',
      namingConvention: 'Atomic',
      primaryLanguage: 'CSS-in-JS',
      tokenFormat: 'camelCase',
    },
    {
      name: 'Marketing Team',
      namingConvention: 'BEM',
      primaryLanguage: 'SCSS',
      tokenFormat: 'kebab-case',
    },
  ],
  brands: [
    {
      name: 'Brand A',
      colorSemantics: {
        danger: '#D32F2F',
        warning: '#FBC02D',
        success: '#388E3C',
      },
      typographyScale: 'numeric', // 100, 200, 300...
    },
    {
      name: 'Brand B',
      colorSemantics: {
        danger: '#B71C1C', // Different red
        warning: '#F57C00', // Different orange
        success: '#2E7D32',
      },
      typographyScale: 'tshirt', // xs, sm, md, lg, xl
    },
  ],
  platforms: [
    { name: 'iOS', tokenFormat: 'camelCase', constraints: ['No dashes', 'No underscores'] },
    { name: 'Android', tokenFormat: 'snake_case', constraints: ['No dashes', 'All lowercase'] },
    { name: 'Web', tokenFormat: 'kebab-case', constraints: ['CSS variable compatible'] },
  ],
  existingTokens: [
    { source: 'Legacy CSS', tokens: ['color-primary', 'color-accent', 'body-text'] },
    { source: 'iOS Codebase', tokens: ['primaryColor', 'accentColor', 'bodyText'] },
  ],
};
```

#### Step 2: MVP Rebranding (15 Components)

```typescript
// mvp-component-analysis.ts
// 15ê°œ í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ë¶„ì„ìœ¼ë¡œ ê°€ì¹˜ ì…ì¦

interface ComponentTokenUsage {
  component: string;
  tokens: {
    colors: string[];
    typography: string[];
    spacing: string[];
    borders: string[];
  };
  conflicts: TokenConflict[];
}

interface TokenConflict {
  type: 'duplicate-name' | 'semantic-mismatch' | 'platform-incompatible';
  description: string;
  affectedTeams: string[];
  priority: 'blocking' | 'high' | 'medium' | 'low';
}

// Example analysis
const buttonAnalysis: ComponentTokenUsage = {
  component: 'Button',
  tokens: {
    colors: ['primary', 'primary-hover', 'primary-disabled'],
    typography: ['button-text', 'button-label'],
    spacing: ['button-padding-x', 'button-padding-y'],
    borders: ['button-radius', 'button-border-width'],
  },
  conflicts: [
    {
      type: 'duplicate-name',
      description: '"button-text" exists in both typography and color categories',
      affectedTeams: ['Product Team', 'Marketing Team'],
      priority: 'high',
    },
    {
      type: 'platform-incompatible',
      description: '"button-padding-x" uses dashes, incompatible with iOS',
      affectedTeams: ['iOS Team'],
      priority: 'blocking',
    },
  ],
};

// Analyze 15 components
const mvpComponents = [
  'Button', 'Input', 'Card', 'Modal', 'Dropdown',
  'Checkbox', 'Radio', 'Switch', 'Badge', 'Tooltip',
  'Alert', 'Progress', 'Tabs', 'Breadcrumb', 'Pagination',
];

const conflictReport = mvpComponents.map(analyzeComponent);
// â†’ Identify top 20 conflicts â†’ Focus efforts
```

#### Step 3: êµ¬ì¡° ë¶„ì„ (Border/BG/Icon/Text)

```typescript
// token-structure-analysis.ts
// ì¹´í…Œê³ ë¦¬ë³„ ëª…ëª… íŒ¨í„´ ë¶„ì„

interface TokenCategory {
  name: string;
  subcategories: string[];
  namingPattern: string;
  examples: string[];
  conflicts: number;
}

const tokenStructure: TokenCategory[] = [
  {
    name: 'Border',
    subcategories: ['width', 'color', 'radius', 'style'],
    namingPattern: 'border-{subcategory}-{variant}-{state}',
    examples: [
      'border-width-thin',      // 1px
      'border-width-medium',    // 2px
      'border-color-default',   // neutral-300
      'border-color-focus',     // primary-500
      'border-radius-sm',       // 4px
      'border-radius-md',       // 8px
    ],
    conflicts: 2, // "thin" vs "1", "small" vs "sm"
  },
  {
    name: 'Background',
    subcategories: ['surface', 'overlay', 'brand'],
    namingPattern: 'bg-{subcategory}-{emphasis}',
    examples: [
      'bg-surface-default',     // white
      'bg-surface-subtle',      // gray-50
      'bg-overlay-modal',       // rgba(0,0,0,0.5)
      'bg-brand-primary',       // primary-500
    ],
    conflicts: 5, // "default" vs "base", "subtle" vs "light"
  },
  {
    name: 'Icon',
    subcategories: ['size', 'color'],
    namingPattern: 'icon-{subcategory}-{variant}',
    examples: [
      'icon-size-sm',           // 16px
      'icon-size-md',           // 24px
      'icon-color-default',     // neutral-600
      'icon-color-muted',       // neutral-400
    ],
    conflicts: 3, // "small" vs "sm" vs "16"
  },
  {
    name: 'Text',
    subcategories: ['color', 'size', 'weight', 'line-height'],
    namingPattern: 'text-{subcategory}-{variant}',
    examples: [
      'text-color-default',     // neutral-900
      'text-color-muted',       // neutral-600
      'text-size-sm',           // 14px
      'text-size-md',           // 16px
      'text-weight-normal',     // 400
      'text-weight-medium',     // 500
    ],
    conflicts: 8, // Highest conflicts!
  },
];

// Text category has most conflicts â†’ Focus here first
```

### í† í° ì¶©ëŒ í•´ê²° íŒ¨í„´

```typescript
// tokens/naming-conflicts.ts
// ì‹¤ì „ ì¶©ëŒ í•´ê²° ì „ëµ

// ì¶©ëŒ 1: Body-medium(size)-medium(weight)
// ë¬¸ì œ: "medium"ì´ sizeì™€ weight ëª¨ë‘ì— ì‚¬ìš©ë¨ â†’ ëª¨í˜¸í•¨
const TYPOGRAPHY_SOLUTIONS = {
  numericSize: 'body-200-medium',     // Sizeë¥¼ ìˆ«ìë¡œ (200 = 16px * 12.5 scale)
  scaledSize: 'body-md-medium',       // Sizeë¥¼ ìŠ¤ì¼€ì¼ë¡œ (xs/sm/md/lg/xl)
  namedSize: 'body-base-medium',      // Sizeë¥¼ ì˜ë¯¸ë¡œ (base/large/small)
} as const;

// ì„ íƒ ê¸°ì¤€:
// - iOS/Android í˜¸í™˜ì„± â†’ scaledSize (ìˆ«ìëŠ” ì¼€ì´ìŠ¤ ë³€í™˜ ë³µì¡)
// - ë””ìì´ë„ˆ ì¹œí™”ì„± â†’ scaledSize (md/lgê°€ ì§ê´€ì )
// - í™•ì¥ì„± â†’ numericSize (200, 250, 300... ë¬´í•œ í™•ì¥)

// ì¶©ëŒ 2: Neutral ë°°ê²½ìƒ‰ 2ê°œ (í°ìƒ‰/íšŒìƒ‰)
// ë¬¸ì œ: ë‘ ê°œì˜ neutral ë°°ê²½ì´ í•„ìš”í•˜ì§€ë§Œ "neutral-default"ë§Œìœ¼ë¡œëŠ” ë¶€ì¡±
const BACKGROUND_SOLUTIONS = {
  defaultSubtle: {
    white: 'neutral-default',      // #FFFFFF
    gray: 'neutral-subtle',        // #F5F5F5
  },
  lowHigh: {
    white: 'neutral-low',          // Emphasis ë‚®ìŒ
    gray: 'neutral-high',          // Emphasis ë†’ìŒ
  },
  emphasisBased: {
    white: 'neutral-emphasis-none',
    gray: 'neutral-emphasis-low',
  },
} as const;

// ìµœì¢… ì„ íƒ: defaultSubtle (ê°€ì¥ ì§ê´€ì , ê¸°ì¡´ ì½”ë“œë² ì´ìŠ¤ì™€ í˜¸í™˜)

// ì¶©ëŒ 3: ë™ì˜ì–´ ë¬¸ì œ (Warning = Alert = Caution?)
// ë¬¸ì œ: ì—¬ëŸ¬ íŒ€ì´ ê°™ì€ ê°œë…ì— ë‹¤ë¥¸ ì´ë¦„ ì‚¬ìš©
const SYNONYM_DB: Record<string, string[]> = {
  warning: ['alert', 'caution', 'attention', 'notice'],
  danger: ['error', 'critical', 'destructive', 'negative'],
  success: ['positive', 'valid', 'confirmed', 'safe'],
  info: ['informational', 'help', 'tip', 'hint'],
};

// í•´ê²°ì±…: Glossaryì—ì„œ 1ê°œë§Œ canonicalë¡œ ì„ íƒ, ë‚˜ë¨¸ì§€ëŠ” alias
type CanonicalToken = 'warning' | 'danger' | 'success' | 'info';

interface TokenGlossaryEntry {
  canonical: CanonicalToken;
  aliases: string[];
  definition: string;
  cssVariable: string;
  platforms: Record<string, string>; // Platform-specific names
}

const glossary: Record<CanonicalToken, TokenGlossaryEntry> = {
  warning: {
    canonical: 'warning',
    aliases: ['alert', 'caution', 'attention'],
    definition: 'Non-critical issue requiring user attention',
    cssVariable: '--color-warning',
    platforms: {
      web: 'color-warning',
      ios: 'colorWarning',
      android: 'color_warning',
    },
  },
  danger: {
    canonical: 'danger',
    aliases: ['error', 'critical', 'destructive'],
    definition: 'Critical issue or destructive action',
    cssVariable: '--color-danger',
    platforms: {
      web: 'color-danger',
      ios: 'colorDanger',
      android: 'color_danger',
    },
  },
  // ... more entries
};
```

### AI Chatbotìœ¼ë¡œ Glossary í•™ìŠµ

```typescript
// ai-token-assistant.ts
// ì»¤ìŠ¤í…€ AI ì±—ë´‡ì— ì œì•½ì‚¬í•­ í•™ìŠµì‹œí‚¤ê¸°

interface TokenContext {
  ecosystem: Ecosystem;
  glossary: Record<string, TokenGlossaryEntry>;
  conflicts: TokenConflict[];
  decisions: DesignDecision[];
}

interface DesignDecision {
  question: string;
  options: string[];
  chosen: string;
  rationale: string;
  date: string;
}

// Example training data
const trainingContext: TokenContext = {
  ecosystem: ecosystemMap, // From Step 1
  glossary: glossary, // From conflict resolution
  conflicts: conflictReport.flat(), // From Step 2
  decisions: [
    {
      question: 'Typography size naming: numeric vs tshirt?',
      options: ['body-200', 'body-md', 'body-base'],
      chosen: 'body-md',
      rationale: 'iOS/Android compatibility + designer familiarity',
      date: '2024-01-15',
    },
    {
      question: 'Neutral background naming?',
      options: ['neutral-default/subtle', 'neutral-low/high'],
      chosen: 'neutral-default/subtle',
      rationale: 'Most intuitive for designers, aligns with existing codebase',
      date: '2024-01-16',
    },
  ],
};

// Generate AI prompt template
function generateAIPrompt(context: TokenContext): string {
  return `
You are a design token naming assistant for a multi-brand, multi-platform design system.

## Constraints
${context.ecosystem.platforms.map(p => `- ${p.name}: ${p.tokenFormat}, ${p.constraints.join(', ')}`).join('\n')}

## Existing Glossary
${Object.entries(context.glossary).map(([key, entry]) =>
  `- **${entry.canonical}**: ${entry.definition} (Aliases: ${entry.aliases.join(', ')})`
).join('\n')}

## Past Decisions
${context.decisions.map(d =>
  `- ${d.question}\n  Chosen: ${d.chosen}\n  Rationale: ${d.rationale}`
).join('\n\n')}

## Your Task
When user asks "What should I name X?", respond with:
1. 3 naming options following our conventions
2. Pros/cons for each option
3. Recommendation based on past decisions
4. Platform-specific transformations

Example:
User: "What should I name a button's hover state background color?"
Assistant:
Options:
1. bg-button-hover (semantic, clear intent)
2. bg-interactive-hover (generic, reusable)
3. bg-primary-hover (color-based, less flexible)

Recommendation: bg-button-hover
- iOS: bgButtonHover
- Android: bg_button_hover
- Web: --bg-button-hover

Rationale: Matches existing "button-text" naming pattern, semantic clarity.
  `.trim();
}

// Use with OpenAI Custom GPT or Claude Projects
const aiPrompt = generateAIPrompt(trainingContext);
// â†’ Paste into ChatGPT/Claude Project instructions
```

---

## Demo 2: Quantum Plugin (AI ì´ìŠˆ ìë™ ìƒì„±)

### ë¬¸ì œ ì •ì˜

**í˜„ì‹¤**: ë””ìì´ë„ˆëŠ” ì´ìŠˆ ì‘ì„±ì„ ì‹«ì–´í•©ë‹ˆë‹¤. ì´ê²ƒì€ íŒ©íŠ¸ì…ë‹ˆë‹¤.
- Figmaì—ì„œ ì»´í¬ë„ŒíŠ¸ë¥¼ ìˆ˜ì •í•˜ê³  ì €ì¥
- Slackì— "Button ì—…ë°ì´íŠ¸í–ˆì–´ìš”!" í•œ ì¤„ ë‚¨ê¹€
- ê°œë°œìëŠ” Dev Modeë¥¼ ì—´ê³  ì§ì ‘ í™•ì¸
- ê°œë°œìê°€ ì¶”ì¸¡ìœ¼ë¡œ ì´ìŠˆ ì‘ì„± â†’ ì˜¤í•´ ë°œìƒ â†’ ì¬ì‘ì—…

**ì´ìƒì  ì„¸ê³„**: ë””ìì´ë„ˆê°€ ì €ì¥í•˜ë©´ ìë™ìœ¼ë¡œ ì™„ë²½í•œ ì´ìŠˆê°€ ìƒì„±
- ë³€ê²½ì‚¬í•­ ìë™ ê°ì§€
- AIê°€ ì˜ë„ ë¶„ì„ ë° ìš”ì•½
- Before/After ìŠ¤í¬ë¦°ìƒ· ìë™ ì²¨ë¶€
- GitHub/Linearì— ì´ìŠˆ ìƒì„±
- Slackì— ì•Œë¦¼

### ì›Œí¬í”Œë¡œìš°

```mermaid
graph TB
    A[Designer: Figmaì—ì„œ Button ìˆ˜ì •] --> B[ì €ì¥ & ë²„ì „ íˆìŠ¤í† ë¦¬ ìƒì„±]
    B --> C[Developer: Quantum Plugin ì‹¤í–‰]
    C --> D[Plugin: ë§ˆì§€ë§‰ ë²„ì „ê³¼ í˜„ì¬ ë²„ì „ ë¹„êµ]
    D --> E[GPT-4 Turbo: ë³€ê²½ì‚¬í•­ ë¶„ì„]

    E --> F{ë³€ê²½ íƒ€ì… ê°ì§€}
    F -->|Style Change| G[ìƒ‰ìƒ/í°íŠ¸/ê°„ê²© ë³€ê²½]
    F -->|Structure Change| H[ë ˆì´ì–´ ì¶”ê°€/ì œê±°]
    F -->|Property Change| I[Auto Layout/Constraints]

    G --> J[AI: ì´ìŠˆ ìƒì„±]
    H --> J
    I --> J

    J --> K[GitHub Issue Created]
    J --> L[Linear Ticket Created]
    K --> M[Slack ì•Œë¦¼]
    L --> M

    style E fill:#dbeafe,stroke:#2563eb
    style J fill:#d1fae5,stroke:#059669
```

1. **ë””ìì´ë„ˆ**: Figmaì—ì„œ ì»´í¬ë„ŒíŠ¸ ìˆ˜ì • í›„ ì €ì¥ (Version History ìë™ ìƒì„±)
2. **ê°œë°œì**: í”ŒëŸ¬ê·¸ì¸ ì‹¤í–‰ -- 1-clickìœ¼ë¡œ ëª¨ë“  ë³€ê²½ì‚¬í•­ ìŠ¤ìº”
3. **GPT-4 Turbo**: ì´ì „ ë²„ì „ê³¼ í˜„ì¬ ë²„ì „ ë¹„êµ â†’ ë³€ê²½ì‚¬í•­ ë¶„ì„
4. **ìë™ ìƒì„±**: GitHub/Linear ì´ìŠˆ
   - ğŸ“ ìš”ì•½: "Primary button hover state darkened from #0052A3 to #003D7A"
   - ğŸ“¸ Before/After ìŠ¤í¬ë¦°ìƒ·
   - âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸: [ ] Update CSS, [ ] Update Storybook, [ ] Test hover
   - ğŸ”— Figma ë§í¬ (direct deeplink)

### ë„êµ¬ ë¹„êµ

| ë„êµ¬ | ìë™í™” ë²”ìœ„ | AI ë¶„ì„ | ì´ìŠˆ ìƒì„± | ë¹„ìš© |
|------|------------|---------|----------|------|
| **Quantum Plugin** | ë³€ê²½ ê°ì§€ + AI ì´ìŠˆ ìƒì„± | âœ… GPT-4 Turbo | âœ… GitHub/Linear | ë¬´ë£Œ (ë² íƒ€) |
| Figma Dev Mode | ìˆ˜ë™ Inspect | âŒ | âŒ | $12/ì›” |
| Zeplin | ë¬¸ì„œí™”ë§Œ | âŒ | âŒ | $8+/ì›” |
| Anima | ì½”ë“œ ìƒì„± | âŒ | âŒ | $31/ì›” |
| **ìˆ˜ë™ í”„ë¡œì„¸ìŠ¤** | - | âŒ | âŒ | ì‹œê°„ 15ë¶„/ì´ìŠˆ |

### Quantum Plugin í•µì‹¬ ê¸°ìˆ 

```typescript
// quantum-plugin-core.ts
// Figma Version History API + GPT-4 Turbo í†µí•©

interface VersionComparison {
  previousVersion: FigmaVersion;
  currentVersion: FigmaVersion;
  changes: Change[];
}

interface Change {
  type: 'style' | 'structure' | 'property' | 'content';
  node: {
    id: string;
    name: string;
    type: string;
  };
  before: any;
  after: any;
  impact: 'breaking' | 'major' | 'minor' | 'patch';
}

interface FigmaVersion {
  id: string;
  created_at: string;
  label: string;
  description: string;
  thumbnail_url: string;
}

// Step 1: Fetch version history
async function getVersionHistory(fileKey: string): Promise<FigmaVersion[]> {
  const response = await fetch(
    `https://api.figma.com/v1/files/${fileKey}/versions`,
    {
      headers: { 'X-Figma-Token': process.env.FIGMA_TOKEN! },
    }
  );
  const data = await response.json();
  return data.versions;
}

// Step 2: Compare two versions
async function compareVersions(
  fileKey: string,
  versionA: string,
  versionB: string
): Promise<VersionComparison> {
  // Fetch both versions
  const [dataA, dataB] = await Promise.all([
    fetchFileAtVersion(fileKey, versionA),
    fetchFileAtVersion(fileKey, versionB),
  ]);

  // Deep diff
  const changes: Change[] = [];

  // Compare nodes recursively
  function compareNodes(nodeA: any, nodeB: any, path: string[]) {
    // Style changes
    if (JSON.stringify(nodeA.fills) !== JSON.stringify(nodeB.fills)) {
      changes.push({
        type: 'style',
        node: { id: nodeA.id, name: nodeA.name, type: nodeA.type },
        before: nodeA.fills,
        after: nodeB.fills,
        impact: determineImpact('fills', nodeA, nodeB),
      });
    }

    // Typography changes
    if (nodeA.style && nodeB.style && JSON.stringify(nodeA.style) !== JSON.stringify(nodeB.style)) {
      changes.push({
        type: 'style',
        node: { id: nodeA.id, name: nodeA.name, type: nodeA.type },
        before: nodeA.style,
        after: nodeB.style,
        impact: determineImpact('typography', nodeA, nodeB),
      });
    }

    // Structure changes
    if (nodeA.children?.length !== nodeB.children?.length) {
      changes.push({
        type: 'structure',
        node: { id: nodeA.id, name: nodeA.name, type: nodeA.type },
        before: { childCount: nodeA.children?.length || 0 },
        after: { childCount: nodeB.children?.length || 0 },
        impact: 'major',
      });
    }

    // Recurse into children
    if (nodeA.children && nodeB.children) {
      for (let i = 0; i < Math.min(nodeA.children.length, nodeB.children.length); i++) {
        compareNodes(nodeA.children[i], nodeB.children[i], [...path, nodeA.name]);
      }
    }
  }

  compareNodes(dataA.document, dataB.document, []);

  return {
    previousVersion: { id: versionA, ...dataA },
    currentVersion: { id: versionB, ...dataB },
    changes,
  };
}

function determineImpact(changeType: string, nodeA: any, nodeB: any): Change['impact'] {
  // Breaking: Component API changed (props added/removed)
  if (changeType === 'structure' && nodeA.type === 'COMPONENT') return 'breaking';

  // Major: Visual appearance significantly changed
  if (changeType === 'fills' && nodeA.fills[0]?.type === 'SOLID') {
    const colorDiff = calculateColorDiff(nodeA.fills[0].color, nodeB.fills[0].color);
    if (colorDiff > 0.3) return 'major'; // 30% diff threshold
  }

  // Minor: Small tweaks
  if (changeType === 'typography' && Math.abs(nodeA.style.fontSize - nodeB.style.fontSize) <= 2) {
    return 'minor';
  }

  return 'patch';
}

// Step 3: Generate screenshots
async function generateScreenshots(
  fileKey: string,
  nodeId: string,
  versions: string[]
): Promise<{ before: string; after: string }> {
  const [before, after] = await Promise.all(
    versions.map(version =>
      fetch(
        `https://api.figma.com/v1/images/${fileKey}?ids=${nodeId}&version=${version}&scale=2`,
        { headers: { 'X-Figma-Token': process.env.FIGMA_TOKEN! } }
      ).then(r => r.json())
    )
  );

  return {
    before: before.images[nodeId],
    after: after.images[nodeId],
  };
}

// Step 4: AI analysis
async function analyzeChangesWithAI(comparison: VersionComparison): Promise<string> {
  const prompt = `
Analyze the following Figma component changes and generate a clear, actionable GitHub issue description.

## Changes Detected
${comparison.changes.map(c => `
- **${c.type}** change in ${c.node.name} (${c.node.type})
  Before: ${JSON.stringify(c.before, null, 2)}
  After: ${JSON.stringify(c.after, null, 2)}
  Impact: ${c.impact}
`).join('\n')}

Generate:
1. **Title**: Concise summary (50 chars max)
2. **Description**: What changed and why it matters
3. **Technical Details**: Specific values (colors, sizes, etc.)
4. **Implementation Checklist**: [ ] Update CSS, [ ] Update tests, etc.
5. **Breaking Changes**: If impact is "breaking", explain what breaks

Format as GitHub-flavored Markdown.
  `.trim();

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-4-turbo',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.3, // Low temp for consistent output
    }),
  });

  const data = await response.json();
  return data.choices[0].message.content;
}

// Step 5: Create GitHub issue
async function createGitHubIssue(
  repo: string,
  title: string,
  body: string,
  screenshots: { before: string; after: string }
): Promise<string> {
  const issueBody = `
${body}

## Visual Comparison

### Before
![Before](${screenshots.before})

### After
![After](${screenshots.after})

---
ğŸ¤– Generated by [Quantum Plugin](https://quantum.figma.com)
  `.trim();

  const response = await fetch(`https://api.github.com/repos/${repo}/issues`, {
    method: 'POST',
    headers: {
      'Authorization': `token ${process.env.GITHUB_TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      title,
      body: issueBody,
      labels: ['design-update', 'figma-sync'],
    }),
  });

  const data = await response.json();
  return data.html_url;
}

// Main workflow
async function quantumSync(fileKey: string, nodeId: string) {
  // 1. Get versions
  const versions = await getVersionHistory(fileKey);
  const [current, previous] = versions.slice(0, 2); // Latest 2

  // 2. Compare
  const comparison = await compareVersions(fileKey, previous.id, current.id);

  if (comparison.changes.length === 0) {
    console.log('No changes detected');
    return;
  }

  // 3. Generate screenshots
  const screenshots = await generateScreenshots(fileKey, nodeId, [previous.id, current.id]);

  // 4. AI analysis
  const issueContent = await analyzeChangesWithAI(comparison);

  // Extract title (first line) and body (rest)
  const [title, ...bodyLines] = issueContent.split('\n');
  const body = bodyLines.join('\n').trim();

  // 5. Create issue
  const issueUrl = await createGitHubIssue('your-org/design-system', title, body, screenshots);

  console.log(`âœ… Issue created: ${issueUrl}`);
}
```

### ì‹¤ì „ ì˜ˆì‹œ ì¶œë ¥

```markdown
Title: Update primary button hover state color

## Description
The primary button's hover state color has been darkened to improve contrast and visual feedback.

## Technical Details
- **Component**: Primary Button
- **Property**: Background color (hover state)
- **Before**: #0052A3 (RGB: 0, 82, 163)
- **After**: #003D7A (RGB: 0, 61, 122)
- **Contrast Ratio**: Improved from 4.8:1 to 6.2:1 (WCAG AA â†’ AAA)

## Implementation Checklist
- [ ] Update CSS variable `--button-primary-hover` in `tokens.css`
- [ ] Update Storybook story for PrimaryButton
- [ ] Test hover state in Chromatic
- [ ] Update design tokens documentation
- [ ] Run accessibility audit (contrast check)

## Breaking Changes
None. This is a visual-only change with no API modifications.

## Related Figma File
[View in Figma](https://figma.com/file/abc123?node-id=456-789&version-id=v123)
```

---

## Demo 3: WCAG Card Deck (Johannes)

### ë¬¸ì œ ì •ì˜

**í˜„ì‹¤**: ì ‘ê·¼ì„± ê°ì‚¬ëŠ” ì••ë„ì ì…ë‹ˆë‹¤.
- WCAG 2.2: 86ê°œ success criteria
- ë¬´ì—‡ë¶€í„° ì‹œì‘? â†’ íŒ€ ë§ˆë¹„
- ëˆ„ê°€ ì±…ì„? ë””ìì´ë„ˆ? ê°œë°œì? â†’ ì±…ì„ íšŒí”¼
- ì–´ë–»ê²Œ ìš°ì„ ìˆœìœ„? â†’ ëª¨ë“  ê²ƒì´ ì¤‘ìš”í•´ ë³´ì„

**ì¶”ê°€ ë¬¸ì œ**: ì ‘ê·¼ì„±ì€ "ì¥ì• ì¸ë§Œì˜ ë¬¸ì œ"ê°€ ì•„ë‹™ë‹ˆë‹¤.
- ìˆ™ì·¨ë¡œ ì¸í•œ ì‹œì•¼ íë¦¼ â†’ Low contrast ë¬¸ì œ
- í¸ë‘í†µìœ¼ë¡œ ì¸í•œ ë¹› ë¯¼ê°ë„ â†’ Animation ë¬¸ì œ
- ë‹¹ë‡¨ë¡œ ì¸í•œ ë–¨ë¦¼ â†’ Small touch target ë¬¸ì œ
- ì†ëª© í„°ë„ ì¦í›„êµ° â†’ Keyboard navigation í•„ìˆ˜
- ë…¸ë ¹í™” â†’ ëª¨ë“  ì ‘ê·¼ì„± ì´ìŠˆì™€ ê´€ë ¨

**í•´ê²°ì±…**: WCAG Card Deck
- ë¬¼ë¦¬ì  ì¹´ë“œ (í¬ì»¤ ì¹´ë“œ í¬ê¸°)
- ê° ì¹´ë“œ = 1ê°œ WCAG criterion
- íŒ€ì´ í•¨ê»˜ í…Œì´ë¸”ì— ì•‰ì•„ ë¶„ë¥˜
- ì±…ì„ ëª…í™•í™”, ìš°ì„ ìˆœìœ„ í˜‘ì˜

### ì¹´ë“œ êµ¬ì„±

```typescript
// wcag-card-structure.ts
interface WCAGCard {
  // Front of card
  id: string;                    // e.g., "1.4.3"
  title: string;                 // e.g., "Contrast (Minimum)"
  level: 'A' | 'AA' | 'AAA';
  shortDescription: string;      // 1-2 sentences

  // Back of card
  fullDescription: string;
  examples: string[];
  disabilityIndicators: DisabilityType[];
  responsibility: Responsibility[];
  testingMethod: 'automated' | 'manual' | 'both';
  qrCode: string;                // wcag.kim/1.4.3

  // Metadata for triage
  priority?: 'blocking' | 'high' | 'medium' | 'low';
  assignedTeam?: 'design' | 'frontend' | 'content' | 'product';
  status?: 'pass' | 'fail' | 'not-applicable';
}

type DisabilityType =
  | 'visual'        // ì‹œê° ì¥ì•  (color blind, low vision, blind)
  | 'auditory'      // ì²­ê° ì¥ì• 
  | 'motor'         // ìš´ë™ ì¥ì•  (keyboard only, tremor)
  | 'cognitive'     // ì¸ì§€ ì¥ì•  (dyslexia, ADHD)
  | 'seizure';      // ë°œì‘ ìœ ë°œ (photosensitive epilepsy)

type Responsibility = 'design' | 'code' | 'content' | 'product';

// Example card
const contrastMinimumCard: WCAGCard = {
  id: '1.4.3',
  title: 'Contrast (Minimum)',
  level: 'AA',
  shortDescription: 'Text must have 4.5:1 contrast ratio against background',

  fullDescription: `
The visual presentation of text and images of text has a contrast ratio of at least:
- 4.5:1 for normal text
- 3:1 for large text (18pt or 14pt bold)
  `.trim(),

  examples: [
    'âœ… Black text (#000000) on white background (#FFFFFF) = 21:1',
    'âœ… Dark gray text (#767676) on white = 4.54:1',
    'âŒ Light gray text (#999999) on white = 2.85:1',
  ],

  disabilityIndicators: ['visual'], // Low vision, color blindness
  responsibility: ['design', 'code'],
  testingMethod: 'automated',
  qrCode: 'https://wcag.kim/1.4.3',
};
```

### 6ë‹¨ê³„ ê°ì‚¬ í”„ë¡œì„¸ìŠ¤

```typescript
// a11y/wcag-audit.ts
const AUDIT_STEPS = [
  '1. í•„í„°ë§: ëª©í‘œ ë ˆë²¨ ì¹´ë“œë§Œ ì„ ë³„',
  '2. ê´€ë ¨ì„± ì‹ë³„: IBM Decision Trees',
  '3. í…Œë§ˆë³„ ê·¸ë£¹í™”: Keyboard, Forms, Color & Contrast',
  '4. ìˆ˜ë™ í…ŒìŠ¤íŠ¸',
  '5. ìš°ì„ ìˆœìœ„: Blocking â†’ High â†’ Medium â†’ Low',
  '6. ì±…ì„ í• ë‹¹: ì¹´ë“œë¥¼ í•´ë‹¹ íŒ€ì— ì „ë‹¬',
] as const;

// Step 1: Filter by level
function filterByLevel(
  cards: WCAGCard[],
  targetLevel: 'A' | 'AA' | 'AAA'
): WCAGCard[] {
  const levelHierarchy = { A: 1, AA: 2, AAA: 3 };
  const targetRank = levelHierarchy[targetLevel];

  return cards.filter(card => levelHierarchy[card.level] <= targetRank);
}

// Example: Company targets WCAG 2.2 Level AA
const allCards: WCAGCard[] = loadAllWCAGCards(); // 86 cards
const relevantCards = filterByLevel(allCards, 'AA'); // ~50 cards
// âœ… Reduced scope from 86 to 50

// Step 2: Identify relevance with IBM Decision Trees
interface DecisionTree {
  question: string;
  yes: string | DecisionTree;
  no: string | DecisionTree;
}

const keyboardNavigationTree: DecisionTree = {
  question: 'Does your site have interactive elements?',
  yes: {
    question: 'Can users complete all actions with keyboard only?',
    yes: 'PASS: 2.1.1 Keyboard',
    no: 'FAIL: 2.1.1 Keyboard - Test this card',
  },
  no: 'NOT APPLICABLE: 2.1.1 Keyboard',
};

// Decision tree helps identify which cards are relevant
// If site has no forms â†’ Skip all form-related cards

// Step 3: Group by theme
type Theme = 'keyboard' | 'forms' | 'color-contrast' | 'multimedia' | 'structure';

interface CardGroup {
  theme: Theme;
  cards: WCAGCard[];
  estimatedEffort: number; // person-hours
}

function groupByTheme(cards: WCAGCard[]): CardGroup[] {
  const themes: Record<Theme, string[]> = {
    'keyboard': ['2.1.1', '2.1.2', '2.4.3', '2.4.7'],
    'forms': ['3.3.1', '3.3.2', '3.3.3', '4.1.3'],
    'color-contrast': ['1.4.3', '1.4.6', '1.4.11'],
    'multimedia': ['1.2.1', '1.2.2', '1.2.3'],
    'structure': ['1.3.1', '2.4.1', '2.4.2', '4.1.2'],
  };

  return Object.entries(themes).map(([theme, ids]) => ({
    theme: theme as Theme,
    cards: cards.filter(c => ids.includes(c.id)),
    estimatedEffort: calculateEffort(cards.filter(c => ids.includes(c.id))),
  }));
}

function calculateEffort(cards: WCAGCard[]): number {
  // Automated tests: 0.5h per card
  // Manual tests: 2h per card
  return cards.reduce((total, card) => {
    if (card.testingMethod === 'automated') return total + 0.5;
    if (card.testingMethod === 'manual') return total + 2;
    return total + 1.5; // 'both'
  }, 0);
}

// Step 4: Manual testing
interface TestResult {
  cardId: string;
  status: 'pass' | 'fail' | 'not-applicable';
  evidence: string; // Screenshot URL, video URL, etc.
  testedBy: string;
  testedAt: Date;
  notes?: string;
}

async function testCard(card: WCAGCard, url: string): Promise<TestResult> {
  // Example: Test 1.4.3 Contrast (Minimum)
  if (card.id === '1.4.3') {
    // Use axe-core for automated testing
    const violations = await runAxeCore(url, ['wcag21aa', 'wcag143']);

    if (violations.length === 0) {
      return {
        cardId: card.id,
        status: 'pass',
        evidence: 'axe-core: 0 violations',
        testedBy: 'automated',
        testedAt: new Date(),
      };
    } else {
      return {
        cardId: card.id,
        status: 'fail',
        evidence: `axe-core: ${violations.length} violations`,
        testedBy: 'automated',
        testedAt: new Date(),
        notes: violations.map(v => v.description).join('; '),
      };
    }
  }

  // Manual testing required
  return {
    cardId: card.id,
    status: 'fail',
    evidence: 'Requires manual testing',
    testedBy: 'pending',
    testedAt: new Date(),
  };
}

// Step 5: Prioritize
function prioritizeIssues(results: TestResult[]): TestResult[] {
  const priorityMap: Record<string, 'blocking' | 'high' | 'medium' | 'low'> = {
    '1.4.3': 'blocking',  // Contrast (affects 8% of population)
    '2.1.1': 'blocking',  // Keyboard (affects 2.5% of users)
    '4.1.2': 'high',      // Name, Role, Value (screen reader compatibility)
    '2.4.7': 'high',      // Focus Visible
    '3.3.1': 'medium',    // Error Identification
    // ... more mappings
  };

  return results
    .filter(r => r.status === 'fail')
    .map(r => ({ ...r, priority: priorityMap[r.cardId] || 'low' }))
    .sort((a, b) => {
      const order = { blocking: 0, high: 1, medium: 2, low: 3 };
      return order[a.priority!] - order[b.priority!];
    });
}

// Step 6: Assign responsibility
function assignResponsibility(card: WCAGCard): string[] {
  const assignments: string[] = [];

  if (card.responsibility.includes('design')) {
    assignments.push('Design Team: Ensure mockups meet contrast/size requirements');
  }

  if (card.responsibility.includes('code')) {
    assignments.push('Frontend Team: Implement ARIA labels, keyboard navigation');
  }

  if (card.responsibility.includes('content')) {
    assignments.push('Content Team: Write descriptive alt text, error messages');
  }

  return assignments;
}

// Full workflow example
async function runWCAGAudit(targetUrl: string, targetLevel: 'AA') {
  // 1. Filter
  const allCards = loadAllWCAGCards();
  const relevantCards = filterByLevel(allCards, targetLevel);
  console.log(`Filtered: ${relevantCards.length} cards`);

  // 2. Decision trees (skip for now, manual process)

  // 3. Group
  const groups = groupByTheme(relevantCards);
  console.log('Groups:', groups.map(g => `${g.theme}: ${g.cards.length} cards (${g.estimatedEffort}h)`));

  // 4. Test
  const results = await Promise.all(
    relevantCards.map(card => testCard(card, targetUrl))
  );

  // 5. Prioritize
  const prioritized = prioritizeIssues(results);
  console.log(`Found ${prioritized.length} issues`);

  // 6. Assign
  prioritized.forEach(result => {
    const card = relevantCards.find(c => c.id === result.cardId)!;
    const assignments = assignResponsibility(card);
    console.log(`[${result.priority}] ${card.title} (${card.id})`);
    assignments.forEach(a => console.log(`  - ${a}`));
  });
}
```

### Physical Card Deck ì‚¬ìš©ë²• (ì›Œí¬ìƒµ)

```typescript
// Physical card triage session (1-2 hours)

interface TriageSession {
  participants: string[];           // ['Designer A', 'Dev B', 'PM C']
  targetLevel: 'A' | 'AA' | 'AAA';
  cards: WCAGCard[];
  triageResults: TriageResult[];
}

interface TriageResult {
  cardId: string;
  status: 'pass' | 'fail' | 'unknown';
  priority: 'blocking' | 'high' | 'medium' | 'low';
  assignedTeam: string;
  estimatedEffort: number;          // hours
  notes: string;
}

// Workshop facilitation script
const workshopSteps = [
  {
    duration: 10,
    step: 'Introduction',
    action: 'Explain WCAG basics, show example violations on your site',
  },
  {
    duration: 15,
    step: 'Filter cards',
    action: 'Remove Level AAA cards if not targeting, remove N/A cards (e.g., no video â†’ skip 1.2.x)',
  },
  {
    duration: 20,
    step: 'Group by theme',
    action: 'Physically arrange cards into piles: Keyboard, Forms, Contrast, etc.',
  },
  {
    duration: 30,
    step: 'Triage each pile',
    action: 'Go through each card, vote Pass/Fail/Unknown, assign priority',
  },
  {
    duration: 15,
    step: 'Assign responsibility',
    action: 'Give blocking/high cards to specific people, set deadlines',
  },
  {
    duration: 10,
    step: 'Create tickets',
    action: 'Input triage results into GitHub/Jira',
  },
];

// Example triage output
const exampleTriageResults: TriageResult[] = [
  {
    cardId: '1.4.3',
    status: 'fail',
    priority: 'blocking',
    assignedTeam: 'Design',
    estimatedEffort: 4,
    notes: 'Gray text on gray backgrounds throughout site',
  },
  {
    cardId: '2.1.1',
    status: 'fail',
    priority: 'blocking',
    assignedTeam: 'Frontend',
    estimatedEffort: 8,
    notes: 'Modal dialogs trap focus, dropdowns not keyboard accessible',
  },
  {
    cardId: '4.1.2',
    status: 'unknown',
    priority: 'high',
    assignedTeam: 'Frontend',
    estimatedEffort: 6,
    notes: 'Need to audit all interactive components with screen reader',
  },
];
```

### Automated Testing Integration

```typescript
// wcag-card-automation.ts
// Map WCAG cards to automated testing rules

interface AutomatedRule {
  cardId: string;
  tool: 'axe-core' | 'lighthouse' | 'pa11y' | 'wave';
  ruleId: string;
}

const AUTOMATED_RULES: AutomatedRule[] = [
  { cardId: '1.4.3', tool: 'axe-core', ruleId: 'color-contrast' },
  { cardId: '2.4.2', tool: 'axe-core', ruleId: 'page-has-heading-one' },
  { cardId: '4.1.2', tool: 'axe-core', ruleId: 'button-name' },
  { cardId: '1.3.1', tool: 'lighthouse', ruleId: 'list' },
  // ... more mappings
];

async function runAutomatedTests(url: string): Promise<Map<string, TestResult>> {
  const results = new Map<string, TestResult>();

  // Run axe-core
  const axeViolations = await runAxeCore(url);
  for (const violation of axeViolations) {
    const rule = AUTOMATED_RULES.find(r => r.ruleId === violation.id && r.tool === 'axe-core');
    if (rule) {
      results.set(rule.cardId, {
        cardId: rule.cardId,
        status: 'fail',
        evidence: `axe-core: ${violation.nodes.length} instances`,
        testedBy: 'automated',
        testedAt: new Date(),
        notes: violation.help,
      });
    }
  }

  // Run Lighthouse
  const lighthouseReport = await runLighthouse(url);
  for (const audit of lighthouseReport.audits) {
    const rule = AUTOMATED_RULES.find(r => r.ruleId === audit.id && r.tool === 'lighthouse');
    if (rule && audit.score < 1) {
      results.set(rule.cardId, {
        cardId: rule.cardId,
        status: 'fail',
        evidence: `Lighthouse: Score ${audit.score}`,
        testedBy: 'automated',
        testedAt: new Date(),
        notes: audit.description,
      });
    }
  }

  return results;
}
```

---

## í†µí•© ì²´í¬ë¦¬ìŠ¤íŠ¸

### Tokens Glossary êµ¬ì¶•
- [ ] 90 Days Canvasë¡œ ìƒíƒœê³„ ë§¤í•‘ (íŒ€, ë¸Œëœë“œ, í”Œë«í¼)
- [ ] MVP 15ê°œ ì»´í¬ë„ŒíŠ¸ ì„ ì • ë° í† í° ë¶„ì„
- [ ] ì¶©ëŒ ë¦¬í¬íŠ¸ ìƒì„± (duplicate names, semantic mismatches)
- [ ] 4ê°œ ì¹´í…Œê³ ë¦¬ ë¶„ì„ (Border, BG, Icon, Text)
- [ ] Glossary êµ¬ì¶• (canonical names + aliases)
- [ ] AI Chatbot í•™ìŠµìš© ì»¨í…ìŠ¤íŠ¸ ìƒì„±
- [ ] í”Œë«í¼ë³„ ë³€í™˜ ê·œì¹™ ì •ì˜ (camelCase, snake_case, kebab-case)

### Quantum Plugin ì„¤ì •
- [ ] Figma íŒŒì¼ì— Version History í™œì„±í™”
- [ ] GitHub/Linear API í† í° ë°œê¸‰
- [ ] OpenAI API í‚¤ ì„¤ì • (GPT-4 Turbo)
- [ ] í”ŒëŸ¬ê·¸ì¸ ì„¤ì¹˜ ë° ê¶Œí•œ ìŠ¹ì¸
- [ ] ì²« í…ŒìŠ¤íŠ¸: ê°„ë‹¨í•œ ìŠ¤íƒ€ì¼ ë³€ê²½ìœ¼ë¡œ ì´ìŠˆ ìƒì„± í™•ì¸
- [ ] íŒ€ì— ì›Œí¬í”Œë¡œìš° êµìœ¡ (ë””ìì´ë„ˆëŠ” ì €ì¥ë§Œ, ê°œë°œìëŠ” í”ŒëŸ¬ê·¸ì¸ ì‹¤í–‰)
- [ ] Slack ì•Œë¦¼ í†µí•©

### WCAG Card Deck ê°ì‚¬
- [ ] ëª©í‘œ ë ˆë²¨ ê²°ì • (A, AA, or AAA)
- [ ] Physical card deck êµ¬ë§¤ ë˜ëŠ” ì¸ì‡„
- [ ] ì›Œí¬ìƒµ ì°¸ê°€ì ì´ˆëŒ€ (ë””ìì´ë„ˆ, ê°œë°œì, PM)
- [ ] 1-2ì‹œê°„ triage session ì§„í–‰
- [ ] Blocking/High ì´ìŠˆ í‹°ì¼“ ìƒì„±
- [ ] ìë™í™” í…ŒìŠ¤íŠ¸ ì„¤ì • (axe-core, Lighthouse)
- [ ] ì£¼ê°„ íšŒê·€ í…ŒìŠ¤íŠ¸ ìŠ¤ì¼€ì¤„ ì„¤ì •

---

## ì‹¤ì „ íƒ€ì„ë¼ì¸ (3ê°œì›”)

| ê¸°ê°„ | í•­ëª© | ë„êµ¬ | ì‚°ì¶œë¬¼ |
|------|------|------|--------|
| Month 1 Week 1-2 | MVP ë¦¬ë¸Œëœë”© + ìƒíƒœê³„ íŒŒì•… | 90 Days Canvas | Ecosystem map, 15 components |
| Month 1 Week 3-4 | ì²´ê³„ì  í† í° ëª…ëª… | Tokens Glossary + GPT | Glossary (50+ entries) |
| Month 2 Week 1-2 | í•¸ë“œì˜¤í”„ ìë™í™” ì„¤ì • | Quantum Plugin (ë² íƒ€) | ì²« 5ê°œ ìë™ ì´ìŠˆ |
| Month 2 Week 3-4 | ì„ì‹œ ìë™í™” ë³´ì™„ | Zapier (Figma â†’ GitHub) | Backup workflow |
| Month 3 Week 1 | WCAG ê°ì‚¬ | Card Deck | Triage results, 20+ tickets |
| Month 3 Week 2-4 | Blocking/High ìˆ˜ì • + ì¬í…ŒìŠ¤íŠ¸ | axe DevTools | 95% WCAG AA compliance |

### 3ê°œì›” í›„ ì„±ê³¼ ì¸¡ì •

```typescript
// roi-measurement.ts
interface ROIMetrics {
  category: string;
  before: number;
  after: number;
  unit: string;
  improvement: string;
}

const expectedROI: ROIMetrics[] = [
  {
    category: 'Token naming conflicts',
    before: 127,
    after: 8,
    unit: 'conflicts',
    improvement: '94% reduction',
  },
  {
    category: 'Design-to-code handoff time',
    before: 45,
    after: 5,
    unit: 'minutes per issue',
    improvement: '89% faster',
  },
  {
    category: 'GitHub issues created manually',
    before: 100,
    after: 20,
    unit: 'issues per month',
    improvement: '80% automation',
  },
  {
    category: 'WCAG violations',
    before: 247,
    after: 12,
    unit: 'violations',
    improvement: '95% resolved',
  },
  {
    category: 'Accessibility audit time',
    before: 40,
    after: 6,
    unit: 'hours',
    improvement: '85% reduction',
  },
];

console.table(expectedROI);
```

---
> ì¶œì²˜: Into Design Systems 2025 Conference - Community Demos Session

---

## Related Articles

import CrossRef from '@site/src/components/CrossRef';

<CrossRef
  related={[
    { path: "/docs/category/01-design-tokens", label: "Design Tokens" },
    { path: "/docs/category/06-accessibility", label: "Accessibility" },
    { path: "/docs/category/07-governance-operations", label: "Governance & Operations" },
  ]}
/>
