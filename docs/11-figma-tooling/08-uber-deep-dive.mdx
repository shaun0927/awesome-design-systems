---
title: "Uber 디자인 시스템 Deep Dive 요약 - 효율화 전략 & 노하우"
sidebar_label: "Uber Deep Dive"
sidebar_position: 8
tags: ["Uber", "variables", "density", "deprecation", "spec"]
---

> Original issue: shaun0927/stocktitan-crawler#509

## Uber 디자인 시스템 Deep Dive 요약

> **출처**: Figma "Deep Dive" 시리즈 — Uber 디자인 시스템 리드 **Ian** 인터뷰
> 디자인 시스템 효율화와 노하우 관점에서 핵심 내용을 정리한 문서입니다.

---

## 1. Uber 디자인 시스템 규모

- 총 **71개 컴포넌트**, 이 중 **20개가 핵심(Core) 컴포넌트**
- 변형(Variation)까지 포함하면 수천 개에 달함
- 현재 Figma 변수(Variables) 기능을 활용해 **전면 리빌드 중**

---

## 2. 컴포넌트 경량화 — Variables를 활용한 배리언트 축소

### 핵심 전략: 컴포넌트 전용 변수(Component-Specific Variables)

기존 방식은 색상/크기 조합마다 별도 배리언트를 만들었지만, 이제는 **하나의 컴포넌트에 변수 모드(Mode)를 적용**하여 변형을 처리한다.

| 항목 | 리팩터링 전 | 리팩터링 후 |
|------|------------|------------|
| Tag 배리언트 | 880개 | 20개 |
| 레이어 수 | 13,000개 | 800개 |
| 컴포넌트 수 | 800개 | 84개 |

### 작동 원리

- **색상 변경**: 배리언트가 아닌 **모드(Mode) 전환**으로 처리 (예: `tag-background`, `tag-border` 등 디자인 전용 토큰)
- 이 토큰들은 기존 시맨틱 토큰을 참조하지만, **디자인에서만 존재**하는 중간 레이어
- 라이브러리 소비자에게는 `Hidden from publishing`으로 숨겨짐
- 코드에서는 프리미티브 토큰을 직접 참조하므로 엔지니어링 구현과 분리됨

### 메모리 최적화 효과

> **핵심 사실**: Figma에서 배리언트 하나를 파일에 가져오면 **모든 배리언트가 함께 로딩**된다.

- Tag 1개를 사용해도 뒤에서 800개가 로딩됨
- Figma 메모리 한도는 2GB: **50%에서 느려지고, 60%에서 경고, 70%에서 저장 불가**
- 컴포넌트 경량화 = 파일 안정성 확보 + 작업 손실 방지

### 리더십에게 리팩터링 가치를 설득하는 방법

- **"Select Layers" 플러그인**으로 레이어/컴포넌트 수를 정량적으로 비교
- 13,000 → 800 레이어 같은 수치를 보여주면 리더십은 **비용 절감**으로 해석
- 핵심 메시지: *"시스템을 가볍게 만들어 디자이너의 파일 손상과 작업 손실을 방지한다"*

---

## 3. 밀도(Density) 시스템 — 제품별 맞춤 컴포넌트

Uber는 **하나의 리스트 컴포넌트**로 모든 제품의 밀도 요구를 충족한다.

| 밀도 모드 | 적용 제품 | 특징 |
|-----------|----------|------|
| **Default** | Rider (택시 호출) | 기본 밀도 |
| **Compact** | Uber Eats (음식 배달) | 밀집 표시, 최소 48×48 터치 타겟 유지 |
| **Spacious** | Earner (드라이버용) | 운전 중 빠른 인지 필요, 넉넉한 여백 |

### 구현 방식

- 디자이너는 단순 **토글 스위치**로 밀도 변경
- 내부적으로는 변수가 `부모 컨테이너 값`, `자식 수직 패딩`, `최소 높이`를 밀도별로 제어
- **접근성 필수**: 모든 밀도에서 **48×48 터치 타겟** 보장

---

## 4. 소프트 디프리케이션(Soft Deprecation) — 안전한 컴포넌트 교체

> *"절대 컴포넌트를 바꿔서 디자이너의 파일을 깨뜨리지 마라"*

### 3단계 프로세스

| 단계 | 조치 | 설명 |
|------|------|------|
| **1단계** | 신규 컴포넌트 추가 + 구 컴포넌트에 `deprecated` 태그 | 디자이너에게 교체 시점 알림 |
| **2단계** | 구 컴포넌트 이름 앞에 `.` 추가 → 라이브러리에서 숨김 | 새로 끌어오기 불가, 기존 파일은 유지 |
| **3단계** | 약 **3개월** 유예 후 완전 삭제 | 메모리 절약 + 유지보수 부담 해소 |

### 왜 즉시 교체하면 안 되는가

- 시간대가 다른 글로벌 팀, 휴가 중인 디자이너 존재
- 구조 변경 시 업데이트를 수락하면 **커스터마이징이 기본값으로 리셋**됨
- 수십~수백 명 디자이너의 소스 파일이 한순간에 깨질 수 있음
- 별도 "deprecated component library"로 이동하는 방식은 유지보수 부담이 과중 → 비권장

---

## 5. 스펙 문서화 — Figma 안에서 엔지니어링 문서 관리

### 왜 Figma 안에서 스펙을 관리하는가

- 디자이너와 엔지니어 모두 **단일 소스(Single Source of Truth)** 사용
- 외부 웹사이트보다 Figma가 최신 상태 유지에 유리
- 엔지니어 설문 결과: Figma에서 직접 토큰/스페이싱을 확인하는 것을 선호

### 파일 구조 (컴포넌트당 1개 파일)

| 페이지 | 내용 |
|--------|------|
| **커버 페이지** | 상태(수정중/리뷰중/완료), 담당자, 최근 수정일 |
| **변경 로그** | 누가, 언제, 무엇을 변경했는지 기록 |
| **탐색(Exploration)** | 제품별 감사(Audit), 기존 사용 사례, "못생긴" 작업 과정 공개 |
| **로컬 컴포넌트** | 실험용 컴포넌트 (UI Kit에 영향 없음) |
| **스펙(Spec)** | 엔지니어를 위한 픽셀 단위 상세 명세 |

### 스펙의 상세 수준

1. **개요** — 컴포넌트 설명, 동작 방식, 사용 가이드라인
2. **해부도(Anatomy)** — Leading / Middle / Trailing 구조 분해
3. **Configuration API** — 엔지니어가 어떻게 호출하는지 플랫폼별 예시
4. **색상 할당** — 모든 상태(Rest, Hover, Press, Focus, Disabled, Loading)별 시맨틱 토큰 매핑
5. **구조 명세** — 러시안 인형 방식으로 바깥→안쪽 순서로 패딩, 최소 높이, 토큰명 명시
6. **밀도별 사양** — Default/Compact/Spacious 각각의 수치
7. **특수 처리** — 이미지 disabled 시 투명도, 로딩 상태(shimmer) 등

### Ian의 검증 질문

> *"내가 없고 이 스펙만 있다면, 엔지니어가 픽셀 퍼펙트로 구현할 수 있는가? 아니라면 내 스펙이 부족한 것이다."*

### 소요 시간 예시

| 컴포넌트 | 기간 | 비고 |
|----------|------|------|
| **리스트** (가장 복잡) | ~5-6개월 | 감사 → 스펙 → 리뷰, 지속적 수정 |
| **버튼** | ~4주 | 3주 개발 + 1주 리뷰 |

### Figma 어노테이션 활용

- Figma의 내장 어노테이션 도구(디자인 모드에서 사용 가능)로 직접 명세
- 바운딩 박스가 보이지 않는 곳에는 **스트로크를 추가**해 시각화
- **과잉 소통(Over-communicate)** 원칙: 상단에도, 하단 표에도 동일 정보를 반복 기재

---

## 6. 컴포넌트 요청 트리아지(Triage) — 새 컴포넌트 판단 기준

### 2단계 필터링

```
요청 접수
  └─ Q1: 시스템 컴포넌트인가, 제품 전용 기능인가?
       ├─ 제품 전용 → "자체 라이브러리에서 구축하세요"
       └─ 시스템 컴포넌트 →
            └─ Q2: 다른 제품에서도 사용 사례가 있는가?
                 ├─ 1~2개 제품만 → 코어 컴포넌트로는 부족
                 └─ 다수 제품 → 감사(Audit) 시작
```

- **99%의 요청**은 제품별 커스텀 기능으로 분류됨
- 코어로 승격되면 **모든 플랫폼(iOS, Android, Web React)** 지원 + 문서화 의무 발생
- 기존 컴포넌트 detach 여부를 확인: *"우리 컴포넌트를 detach해서 커스텀한 적 있나요?"* → 있으면 시스템 개선 기회

### 기여 모델(Contribution Model)

5개 팀이 동시에 필요로 하는 경우:
1. 각 팀의 탐색 결과를 취합
2. **접근성 검토** (선택 상태, 터치 타겟 등) — 최소 요구사항
3. Ian이 스펙 작성을 리드하되, 팀 디자이너들과 **함께 반복**
4. 스펙 승인 후 **피처 엔지니어가 코어 시스템에 기여** 가능
5. 긴급한 경우 리소스를 모아 빠르게 구축

---

## 7. 감사(Audit) & 탐색(Exploration) 프로세스

### 감사 단계에서 하는 일

- 각 제품(Delivery, Rider, Earner, Merchant)에서 해당 컴포넌트가 어떻게 사용되는지 조사
- 제품팀 디자이너와 직접 미팅: *"우리 컴포넌트를 어떻게 깨뜨렸나요?"*
- 내부 리소스(과거 문서, 가이드) 검토
- **목표: 하나의 컴포넌트로 정규화(Normalize)** — 모든 제품에 통용되는 형태 도출

### 90% 커버리지 원칙

> *"시스템 컴포넌트는 모든 제품의 90%를 커버해야 한다. 나머지 10%는 정규화하거나, 해당 제품의 진정한 커스텀으로 인정한다."*

### 리빙 도큐먼트(Living Document)

- 스펙은 **절대 완료되지 않음** — 새로운 사용 사례가 발견되면 감사 → 업데이트
- 버전 관리: 탐색 파일에 v5.5, v6 MC V3 등으로 이력 관리
- *"작업은 절대 끝나지 않는다. 내일 새로운 탐색이 생기기 때문이다."*

---

## 8. Composable Slots — 예측 불가능한 콘텐츠 대응

| 관점 | 접근 방식 |
|------|----------|
| **디자인** | 미리 정의된 옵션만 노출 (아이콘, 텍스트 등 선택지) → 규칙 강제 |
| **코드** | Leading/Trailing 영역을 **합성 가능한 슬롯**으로 구현 → 커스텀 주입 가능 |

- 디자이너는 규칙을 따르도록 유도하면서, 엔지니어에게는 유연성을 제공
- 결과: 컴포넌트 수명 **2년 이상** 유지 가능

---

## 9. UI Kit vs 스펙 파일 분리

| 구분 | UI Kit (디자이너용) | 스펙 파일 (엔지니어용) |
|------|--------------------|-----------------------|
| **목적** | 디자이너가 실제 사용하는 컴포넌트 | 픽셀 퍼펙트 구현 가이드 |
| **최적화** | 변수로 배리언트 축소, 메모리 경량화 | 모든 변형을 배리언트로 펼쳐서 명세 |
| **안정성** | Evergreen — 항상 안정된 상태 유지 | 실험/수정이 빈번 |
| **분리 이유** | 스펙 작업 중 발생하는 불안정성이 디자이너에게 영향 없음 |

---

## 10. 컴포넌트 변경에 대한 열린 태도

> *"옳지 않을 수 있다는 것을 받아들여라. 한 사람이 전체 사고를 바꿀 수 있다."*

- 누군가 더 나은 대안을 제시하면 **열린 마음으로 검토**
- 판단 기준: *"다른 제품에도 적용 가능한가?"* + *"구현 가능한가?"*
- 시스템 컴포넌트의 영향 범위를 설명하면 대부분 스스로 판단:
  *"이건 다른 제품에는 안 맞겠네요"*
- **오픈 디자인**: 탐색, 감사, 의사결정 과정을 모두 공개 → 누구나 기여 가능

---

## 11. 핵심 교훈 요약

| 원칙 | 설명 |
|------|------|
| **변수로 배리언트를 대체하라** | 색상, 밀도 등을 모드로 처리하면 컴포넌트 수가 극적으로 줄어든다 |
| **메모리는 곧 비용이다** | Figma에서 1개 배리언트 = 전체 배리언트 로딩. 경량화가 곧 생산성 |
| **소프트 디프리케이션은 필수** | 3개월 유예 + 숨김 → 삭제. 절대 파일을 깨뜨리지 마라 |
| **스펙은 엔지니어의 자립을 목표로** | "내가 없어도 픽셀 퍼펙트 구현 가능"이 기준 |
| **오픈 디자인 프로세스** | 탐색, 감사, 의사결정 과정을 모두 공개하라 |
| **90% 커버리지 + 10% 커스텀** | 완벽한 범용보다 실용적 범위 설정 |
| **80%는 소통, 20%가 디자인** | 시스템의 가치를 설명하고 교육하는 것이 핵심 업무 |
| **스펙 능력 = 슈퍼파워** | 컴포넌트를 이 수준으로 명세할 수 있으면 무엇이든 만들 수 있다 |
| **detach 질문으로 개선 기회 포착** | "우리 컴포넌트를 detach한 적 있나요?" → 시스템 개선 신호 |
| **기여 모델로 확장** | 여러 팀이 필요로 하면 함께 만들고, 피처 엔지니어도 코어에 기여 가능 |

---

## Related Articles

import CrossRef from '@site/src/components/CrossRef';

<CrossRef
  related={[
    { path: "/docs/category/03-component-design", label: "Component Design" },
    { path: "/docs/category/08-scaling-architecture", label: "Scaling & Architecture" },
    { path: "/docs/category/01-design-tokens", label: "Design Tokens" },
  ]}
/>
