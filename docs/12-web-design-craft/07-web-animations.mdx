---
title: "웹 애니메이션 구현 노하우 정리 - The Easy Way to Do Web Animations"
sidebar_label: "웹 애니메이션"
sidebar_position: 7
audience: developer
tags: ["animations", "CSS", "motion", "UX", "performance"]
---

import DevQuickStart from '@site/src/components/DevQuickStart';
import CrossRef from '@site/src/components/CrossRef';

<DevQuickStart
  what="웹 애니메이션의 핵심은 CSS Transform/Opacity(GPU 가속)와 JavaScript 동적 제어입니다"
  learn="CSS 애니메이션, Web Animations API, SVG Path, 성능 최적화"
  able="CSS와 JS로 60fps 웹 애니메이션을 구현할 수 있습니다"
/>

## Animation vs Transition

```css
/* Transition: 상태 변화에 반응 */
.button {
  background: blue;
  transition: all 0.3s ease-out;
}

.button:hover {
  background: darkblue;
  transform: scale(1.05);
}

/* Animation: 자동 재생, 반복 가능 */
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.notification {
  animation: pulse 2s ease-in-out infinite;
}
```

---

## Timing Functions

```css
/* 선형: 일정한 속도 */
.linear { transition: transform 1s linear; }

/* Ease: 시작/끝 느림 (기본값) */
.ease { transition: transform 1s ease; }

/* Ease-in: 느리게 시작, 빠르게 끝 */
.ease-in { transition: transform 1s ease-in; }

/* Ease-out: 빠르게 시작, 느리게 끝 (자연스러움) */
.ease-out { transition: transform 1s ease-out; }

/* Ease-in-out: 느림-빠름-느림 (부드러움) */
.ease-in-out { transition: transform 1s ease-in-out; }

/* Custom Bezier: https://cubic-bezier.com */
.custom { transition: transform 1s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
```

**권장:** `ease-out` (자연스러운 감속) 또는 `cubic-bezier` (커스텀 곡선)

---

## 기본 CSS 애니메이션

### Transform

```css
/* Translate: 이동 */
.slide-in {
  animation: slideIn 0.5s ease-out;
}

@keyframes slideIn {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Scale: 확대/축소 */
.zoom-in {
  animation: zoomIn 0.3s ease-out;
}

@keyframes zoomIn {
  from {
    transform: scale(0.8);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

/* Rotate: 회전 */
.spin {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
```

### Opacity

```css
/* Fade In/Out */
.fade-in {
  animation: fadeIn 0.4s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.fade-out {
  animation: fadeOut 0.4s ease-out;
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}
```

---

## 고급 Transition 패턴

### Ghost Element 내비게이션

```tsx
export function TabNav({ tabs, activeTab }: TabNavProps) {
  const [ghostStyle, setGhostStyle] = useState({});
  const tabRefs = useRef<(HTMLButtonElement | null)[]>([]);

  useEffect(() => {
    const activeEl = tabRefs.current[activeTab];
    if (activeEl) {
      setGhostStyle({
        width: activeEl.offsetWidth,
        left: activeEl.offsetLeft,
      });
    }
  }, [activeTab]);

  return (
    <nav className="tab-nav">
      <div className="ghost-element" style={ghostStyle} />
      {tabs.map((tab, idx) => (
        <button
          key={idx}
          ref={(el) => (tabRefs.current[idx] = el)}
          className={activeTab === idx ? 'active' : ''}
        >
          {tab}
        </button>
      ))}
    </nav>
  );
}
```

```css
.tab-nav {
  position: relative;
  display: flex;
  gap: 1rem;
}

.ghost-element {
  position: absolute;
  bottom: 0;
  height: 3px;
  background: var(--color-primary);
  transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
```

### Shine Effect

```css
.button-shine {
  position: relative;
  overflow: hidden;
}

.button-shine::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  transition: left 0.5s;
}

.button-shine:hover::before {
  left: 100%;
}
```

---

## 3D Transform 애니메이션

### 3D 카드 플립

```tsx
export function FlipCard({ front, back }: FlipCardProps) {
  const [isFlipped, setIsFlipped] = useState(false);

  return (
    <div className="flip-card" onClick={() => setIsFlipped(!isFlipped)}>
      <div className={`flip-inner ${isFlipped ? 'flipped' : ''}`}>
        <div className="flip-front">{front}</div>
        <div className="flip-back">{back}</div>
      </div>
    </div>
  );
}
```

```css
.flip-card {
  perspective: 1000px;
  width: 300px;
  height: 400px;
}

.flip-inner {
  position: relative;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

.flip-inner.flipped {
  transform: rotateY(180deg);
}

.flip-front,
.flip-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  border-radius: 12px;
}

.flip-back {
  transform: rotateY(180deg);
}
```

---

## JavaScript 동적 애니메이션

### Clone & Fly (장바구니 효과)

```tsx
export function AddToCartButton({ productId }: { productId: string }) {
  const buttonRef = useRef<HTMLButtonElement>(null);

  const handleClick = () => {
    if (!buttonRef.current) return;

    // 1. 클론 생성
    const clone = buttonRef.current.cloneNode(true) as HTMLElement;
    clone.style.position = 'fixed';
    clone.style.zIndex = '9999';

    // 2. 시작 위치 계산
    const rect = buttonRef.current.getBoundingClientRect();
    clone.style.left = `${rect.left}px`;
    clone.style.top = `${rect.top}px`;

    document.body.appendChild(clone);

    // 3. 목적지 위치 계산 (장바구니 아이콘)
    const cart = document.querySelector('.cart-icon')!;
    const cartRect = cart.getBoundingClientRect();

    // 4. Web Animations API로 애니메이션
    clone.animate([
      { transform: 'translate(0, 0) scale(1)', opacity: 1 },
      { transform: `translate(${cartRect.left - rect.left}px, ${cartRect.top - rect.top}px) scale(0.3)`, opacity: 0 }
    ], {
      duration: 600,
      easing: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)'
    }).onfinish = () => {
      clone.remove();
    };
  };

  return (
    <button ref={buttonRef} onClick={handleClick}>
      Add to Cart
    </button>
  );
}
```

### Stagger Animation

```tsx
export function StaggerList({ items }: { items: string[] }) {
  return (
    <ul className="stagger-list">
      {items.map((item, idx) => (
        <li
          key={idx}
          style={{ animationDelay: `${idx * 0.1}s` }}
        >
          {item}
        </li>
      ))}
    </ul>
  );
}
```

```css
.stagger-list li {
  opacity: 0;
  animation: fadeInUp 0.5s ease-out forwards;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
```

---

## SVG Path 애니메이션

### Path Drawing

```tsx
export function AnimatedLogo() {
  return (
    <svg viewBox="0 0 100 100" className="animated-logo">
      <path
        d="M 10,30 A 20,20 0,0,1 50,30 A 20,20 0,0,1 90,30"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        pathLength="100"
        className="logo-path"
      />
    </svg>
  );
}
```

```css
.logo-path {
  stroke-dasharray: 100;
  stroke-dashoffset: 100;
  animation: draw 2s ease-out forwards;
}

@keyframes draw {
  to {
    stroke-dashoffset: 0;
  }
}
```

### Path Following

```css
.icon {
  offset-path: path('M 10,80 Q 52.5,10 95,80');
  animation: followPath 2s ease-in-out infinite;
}

@keyframes followPath {
  from {
    offset-distance: 0%;
  }
  to {
    offset-distance: 100%;
  }
}
```

---

## 성능 최적화

### GPU 가속 속성 우선

```css
/* ✅ GPU 가속 (60fps) */
.fast {
  transform: translateX(100px);
  opacity: 0.5;
}

/* ❌ CPU 가속 (느림, 레이아웃 재계산) */
.slow {
  left: 100px;
  background: red;
}
```

### Will-Change 힌트

```css
.animated-element {
  /* 애니메이션 직전에만 적용 */
  will-change: transform, opacity;
}

/* 애니메이션 완료 후 제거 */
.animated-element.idle {
  will-change: auto;
}
```

### Reduce Motion

```css
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
```

---

## 체크리스트

### 구현 전
- [ ] Transition으로 충분한가, Keyframes 필요한가?
- [ ] GPU 가속 속성(transform, opacity) 우선 사용?
- [ ] 사용자 경험에 실질적 가치를 주는가?

### 구현 중
- [ ] Timing function이 움직임의 의도를 표현하는가?
- [ ] CSS 변수로 재사용 가능하게 설계했는가?
- [ ] 3D 애니메이션이면 perspective 설정했는가?

### 구현 후
- [ ] 모바일에서도 60fps 유지되는가?
- [ ] `prefers-reduced-motion` 처리했는가?
- [ ] 애니메이션 타이밍이 사용자 행동과 동기화되는가?

---

<CrossRef
  related={[
    { path: "/docs/category/02-visual-foundations", label: "Visual Foundations" },
    { path: "/docs/category/03-component-design", label: "Component Design" },
    { path: "/docs/category/06-accessibility", label: "Accessibility" },
  ]}
/>
